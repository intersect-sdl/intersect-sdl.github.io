import{g as Qt}from"./_commonjsHelpers-gnU0ypJ3.js";import{r as Kt}from"./___vite-browser-external_commonjs-proxy-CVH6f9gb.js";function Wt(v,s){for(var g=0;g<s.length;g++){const p=s[g];if(typeof p!="string"&&!Array.isArray(p)){for(const A in p)if(A!=="default"&&!(A in v)){const r=Object.getOwnPropertyDescriptor(p,A);r&&Object.defineProperty(v,A,r.get?r:{enumerable:!0,get:()=>p[A]})}}}return Object.freeze(Object.defineProperty(v,Symbol.toStringTag,{value:"Module"}))}var pe={},ge,rt;function Ce(){return rt||(rt=1,ge=class Pt{constructor(s,g=new Map,p=0){this.prefix=s,this._existing=g,this.counter=p}clone(){const{prefix:s,_existing:g,counter:p}=this;return new Pt(s,new Map(g),p)}getId(s){const g=s&&this._existing.get(s);if(g)return g;const p=this.prefix+this.counter;return this.counter++,s&&this._existing.set(s,p),p}hasId(s){return this._existing.has(s)}getOldIds(){return[...this._existing.keys()]}}),ge}var ye={},it;function Yt(){return it||(it=1,(function(v,s){if(v.setImmediate)return;var g=1,p={},A=!1,r=v.document,t;function n(k){typeof k!="function"&&(k=new Function(""+k));for(var f=new Array(arguments.length-1),e=0;e<f.length;e++)f[e]=arguments[e+1];var i={callback:k,args:f};return p[g]=i,t(g),g++}function a(k){delete p[k]}function b(k){var f=k.callback,e=k.args;switch(e.length){case 0:f();break;case 1:f(e[0]);break;case 2:f(e[0],e[1]);break;case 3:f(e[0],e[1],e[2]);break;default:f.apply(s,e);break}}function N(k){if(A)setTimeout(N,0,k);else{var f=p[k];if(f){A=!0;try{b(f)}finally{a(k),A=!1}}}}function D(){t=function(k){process.nextTick(function(){N(k)})}}function u(){if(v.postMessage&&!v.importScripts){var k=!0,f=v.onmessage;return v.onmessage=function(){k=!1},v.postMessage("","*"),v.onmessage=f,k}}function l(){var k="setImmediate$"+Math.random()+"$",f=function(e){e.source===v&&typeof e.data=="string"&&e.data.indexOf(k)===0&&N(+e.data.slice(k.length))};v.addEventListener?v.addEventListener("message",f,!1):v.attachEvent("onmessage",f),t=function(e){v.postMessage(k+e,"*")}}function w(){var k=new MessageChannel;k.port1.onmessage=function(f){var e=f.data;N(e)},t=function(f){k.port2.postMessage(f)}}function _(){var k=r.documentElement;t=function(f){var e=r.createElement("script");e.onreadystatechange=function(){N(f),e.onreadystatechange=null,k.removeChild(e),e=null},k.appendChild(e)}}function O(){t=function(k){setTimeout(N,0,k)}}var H=Object.getPrototypeOf&&Object.getPrototypeOf(v);H=H&&H.setTimeout?H:v,{}.toString.call(v.process)==="[object process]"?D():u()?l():v.MessageChannel?w():r&&"onreadystatechange"in r.createElement("script")?_():O(),H.setImmediate=n,H.clearImmediate=a})(typeof self>"u"?typeof globalThis>"u"?ye:globalThis:self)),ye}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var ve,st;function ue(){if(st)return ve;st=1,Yt();const v=self.crypto||self.msCrypto;return ve=class{constructor(g){if(!(v&&v.subtle))throw new Error("crypto.subtle not found.");if(g==="sha256")this.algorithm={name:"SHA-256"};else if(g==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${g}".`);this._content=""}update(g){this._content+=g}async digest(){const g=new TextEncoder().encode(this._content),p=new Uint8Array(await v.subtle.digest(this.algorithm,g));let A="";for(let r=0;r<p.length;++r)A+=p[r].toString(16).padStart(2,"0");return A}},ve}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var me,at;function Bt(){return at||(at=1,me=class{constructor(s){this.current=s.sort(),this.done=!1,this.dir=new Map;for(let g=0;g<s.length;++g)this.dir.set(s[g],!0)}hasNext(){return!this.done}next(){const{current:s,dir:g}=this,p=s.slice();let A=null,r=0;const t=s.length;for(let n=0;n<t;++n){const a=s[n],b=g.get(a);(A===null||a>A)&&(b&&n>0&&a>s[n-1]||!b&&n<t-1&&a>s[n+1])&&(A=a,r=n)}if(A===null)this.done=!0;else{const n=g.get(A)?r-1:r+1;s[r]=s[n],s[n]=A;for(const a of s)a>A&&g.set(a,!g.get(a))}return p}}),me}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var be,ot;function Ze(){if(ot)return be;ot=1;const s="http://www.w3.org/1999/02/22-rdf-syntax-ns#"+"langString",g="http://www.w3.org/2001/XMLSchema#string",p="NamedNode",A="BlankNode",r="Literal",t="DefaultGraph",n={};(()=>{const l="(?:<([^:]+:[^>]*)>)",_="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",O=_+"0-9-·̀-ͯ‿-⁀",k="(_:(?:["+_+"0-9])(?:(?:["+O+".])*(?:["+O+"]))?)",f='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',e="(?:\\^\\^"+l+")",c="(?:"+f+"(?:"+e+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",j="[ \\t]+",d="[ \\t]*",x="(?:"+l+"|"+k+")"+j,m=l+j,J="(?:"+l+"|"+k+"|"+c+")"+d,M="(?:\\.|(?:(?:"+l+"|"+k+")"+d+"\\.))";n.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,n.empty=new RegExp("^"+d+"$"),n.quad=new RegExp("^"+d+x+m+J+M+d+"$")})(),be=class ce{static parse(w){const _=[],O={},H=w.split(n.eoln);let k=0;for(const f of H){if(k++,n.empty.test(f))continue;const e=f.match(n.quad);if(e===null)throw new Error("N-Quads parse error on line "+k+".");const i={subject:null,predicate:null,object:null,graph:null};if(e[1]!==void 0?i.subject={termType:p,value:e[1]}:i.subject={termType:A,value:e[2]},i.predicate={termType:p,value:e[3]},e[4]!==void 0?i.object={termType:p,value:e[4]}:e[5]!==void 0?i.object={termType:A,value:e[5]}:(i.object={termType:r,value:void 0,datatype:{termType:p}},e[7]!==void 0?i.object.datatype.value=e[7]:e[8]!==void 0?(i.object.datatype.value=s,i.object.language=e[8]):i.object.datatype.value=g,i.object.value=u(e[6])),e[9]!==void 0?i.graph={termType:p,value:e[9]}:e[10]!==void 0?i.graph={termType:A,value:e[10]}:i.graph={termType:t,value:""},!(i.graph.value in O))O[i.graph.value]=[i],_.push(i);else{let c=!0;const j=O[i.graph.value];for(const d of j)if(a(d,i)){c=!1;break}c&&(j.push(i),_.push(i))}}return _}static serialize(w){Array.isArray(w)||(w=ce.legacyDatasetToQuads(w));const _=[];for(const O of w)_.push(ce.serializeQuad(O));return _.sort().join("")}static serializeQuadComponents(w,_,O,H){let k="";return w.termType===p?k+=`<${w.value}>`:k+=`${w.value}`,k+=` <${_.value}> `,O.termType===p?k+=`<${O.value}>`:O.termType===A?k+=O.value:(k+=`"${N(O.value)}"`,O.datatype.value===s?O.language&&(k+=`@${O.language}`):O.datatype.value!==g&&(k+=`^^<${O.datatype.value}>`)),H.termType===p?k+=` <${H.value}>`:H.termType===A&&(k+=` ${H.value}`),k+=` .
`,k}static serializeQuad(w){return ce.serializeQuadComponents(w.subject,w.predicate,w.object,w.graph)}static legacyDatasetToQuads(w){const _=[],O={"blank node":A,IRI:p,literal:r};for(const H in w)w[H].forEach(f=>{const e={};for(const i in f){const c=f[i],j={termType:O[c.type],value:c.value};j.termType===r&&(j.datatype={termType:p},"datatype"in c&&(j.datatype.value=c.datatype),"language"in c?("datatype"in c||(j.datatype.value=s),j.language=c.language):"datatype"in c||(j.datatype.value=g)),e[i]=j}H==="@default"?e.graph={termType:t,value:""}:e.graph={termType:H.startsWith("_:")?A:p,value:H},_.push(e)});return _}};function a(l,w){return!(l.subject.termType===w.subject.termType&&l.object.termType===w.object.termType)||!(l.subject.value===w.subject.value&&l.predicate.value===w.predicate.value&&l.object.value===w.object.value)?!1:l.object.termType!==r?!0:l.object.datatype.termType===w.object.datatype.termType&&l.object.language===w.object.language&&l.object.datatype.value===w.object.datatype.value}const b=/["\\\n\r]/g;function N(l){return l.replace(b,function(w){switch(w){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const D=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function u(l){return l.replace(D,function(w,_,O,H){if(_)switch(_){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(O)return String.fromCharCode(parseInt(O,16));if(H)throw new Error("Unsupported U escape")})}return be}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var we,lt;function Vt(){if(lt)return we;lt=1;const v=Ce(),s=ue(),g=Bt(),p=Ze();we=class{constructor({createMessageDigest:t=()=>new s("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:a=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new v("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=a,this.quads=null,this.deepIterations=null}async main(t){this.deepIterations=new Map,this.quads=t;for(const l of t)this._addBlankNodeQuadInfo({quad:l,component:l.subject}),this._addBlankNodeQuadInfo({quad:l,component:l.object}),this._addBlankNodeQuadInfo({quad:l,component:l.graph});const n=new Map,a=[...this.blankNodeInfo.keys()];let b=0;for(const l of a)++b%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:l,hashToBlankNodes:n});const N=[...n.keys()].sort(),D=[];for(const l of N){const w=n.get(l);if(w.length>1){D.push(w);continue}const _=w[0];this.canonicalIssuer.getId(_)}for(const l of D){const w=[];for(const _ of l){if(this.canonicalIssuer.hasId(_))continue;const O=new v("_:b");O.getId(_);const H=await this.hashNDegreeQuads(_,O);w.push(H)}w.sort(A);for(const _ of w){const O=_.issuer.getOldIds();for(const H of O)this.canonicalIssuer.getId(H)}}const u=[];for(const l of this.quads){const w=p.serializeQuadComponents(this._componentWithCanonicalId(l.subject),l.predicate,this._componentWithCanonicalId(l.object),this._componentWithCanonicalId(l.graph));u.push(w)}return u.sort(),u.join("")}async hashFirstDegreeQuads(t){const n=[],a=this.blankNodeInfo.get(t),b=a.quads;for(const D of b){const u={subject:null,predicate:D.predicate,object:null,graph:null};u.subject=this.modifyFirstDegreeComponent(t,D.subject,"subject"),u.object=this.modifyFirstDegreeComponent(t,D.object,"object"),u.graph=this.modifyFirstDegreeComponent(t,D.graph,"graph"),n.push(p.serializeQuad(u))}n.sort();const N=this.createMessageDigest();for(const D of n)N.update(D);return a.hash=await N.digest(),a.hash}async hashRelatedBlankNode(t,n,a,b){let N;this.canonicalIssuer.hasId(t)?N=this.canonicalIssuer.getId(t):a.hasId(t)?N=a.getId(t):N=this.blankNodeInfo.get(t).hash;const D=this.createMessageDigest();return D.update(b),b!=="g"&&D.update(this.getRelatedPredicate(n)),D.update(N),D.digest()}async hashNDegreeQuads(t,n){const a=this.deepIterations.get(t)||0;if(a>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,a+1);const b=this.createMessageDigest(),N=await this.createHashToRelated(t,n),D=[...N.keys()].sort();for(const u of D){b.update(u);let l="",w;const _=new g(N.get(u));let O=0;for(;_.hasNext();){const H=_.next();++O%3===0&&await this._yield();let k=n.clone(),f="";const e=[];let i=!1;for(const c of H)if(this.canonicalIssuer.hasId(c)?f+=this.canonicalIssuer.getId(c):(k.hasId(c)||e.push(c),f+=k.getId(c)),l.length!==0&&f>l){i=!0;break}if(!i){for(const c of e){const j=await this.hashNDegreeQuads(c,k);if(f+=k.getId(c),f+=`<${j.hash}>`,k=j.issuer,l.length!==0&&f>l){i=!0;break}}i||(l.length===0||f<l)&&(l=f,w=k)}}b.update(l),n=w}return{hash:await b.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,n){const a=new Map,b=this.blankNodeInfo.get(t).quads;let N=0;for(const D of b)++N%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:D,component:D.subject,position:"s",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:D,component:D.object,position:"o",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:D,component:D.graph,position:"g",id:t,issuer:n,hashToRelated:a})]);return a}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const a=await this.hashFirstDegreeQuads(t),b=n.get(a);b?b.push(t):n.set(a,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const a=n.value,b=this.blankNodeInfo.get(a);b?b.quads.add(t):this.blankNodeInfo.set(a,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:n,position:a,id:b,issuer:N,hashToRelated:D}){if(!(n.termType==="BlankNode"&&n.value!==b))return;const u=n.value,l=await this.hashRelatedBlankNode(u,t,N,a),w=D.get(l);w?w.push(u):D.set(l,[u])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>setImmediate(t))}};function A(r,t){return r.hash<t.hash?-1:r.hash>t.hash?1:0}return we}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ie,ct;function Ct(){if(ct)return Ie;ct=1;const v=ue(),s=Vt();return Ie=class extends s{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new v("sha1")}modifyFirstDegreeComponent(p,A,r){return A.termType!=="BlankNode"?A:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:A.value===p?"_:a":"_:z"}}getRelatedPredicate(p){return p.predicate.value}async createHashToRelated(p,A){const r=new Map,t=this.blankNodeInfo.get(p).quads;let n=0;for(const a of t){let b,N;if(a.subject.termType==="BlankNode"&&a.subject.value!==p)N=a.subject.value,b="p";else if(a.object.termType==="BlankNode"&&a.object.value!==p)N=a.object.value,b="r";else continue;++n%100===0&&await this._yield();const D=await this.hashRelatedBlankNode(N,a,A,b),u=r.get(D);u?u.push(N):r.set(D,[N])}return r}},Ie}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var xe,ut;function Gt(){if(ut)return xe;ut=1;const v=Ce(),s=ue(),g=Bt(),p=Ze();xe=class{constructor({createMessageDigest:t=()=>new s("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:a=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new v("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=a,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const u of t)this._addBlankNodeQuadInfo({quad:u,component:u.subject}),this._addBlankNodeQuadInfo({quad:u,component:u.object}),this._addBlankNodeQuadInfo({quad:u,component:u.graph});const n=new Map,a=[...this.blankNodeInfo.keys()];for(const u of a)this._hashAndTrackBlankNode({id:u,hashToBlankNodes:n});const b=[...n.keys()].sort(),N=[];for(const u of b){const l=n.get(u);if(l.length>1){N.push(l);continue}const w=l[0];this.canonicalIssuer.getId(w)}for(const u of N){const l=[];for(const w of u){if(this.canonicalIssuer.hasId(w))continue;const _=new v("_:b");_.getId(w);const O=this.hashNDegreeQuads(w,_);l.push(O)}l.sort(A);for(const w of l){const _=w.issuer.getOldIds();for(const O of _)this.canonicalIssuer.getId(O)}}const D=[];for(const u of this.quads){const l=p.serializeQuadComponents(this._componentWithCanonicalId({component:u.subject}),u.predicate,this._componentWithCanonicalId({component:u.object}),this._componentWithCanonicalId({component:u.graph}));D.push(l)}return D.sort(),D.join("")}hashFirstDegreeQuads(t){const n=[],a=this.blankNodeInfo.get(t),b=a.quads;for(const D of b){const u={subject:null,predicate:D.predicate,object:null,graph:null};u.subject=this.modifyFirstDegreeComponent(t,D.subject,"subject"),u.object=this.modifyFirstDegreeComponent(t,D.object,"object"),u.graph=this.modifyFirstDegreeComponent(t,D.graph,"graph"),n.push(p.serializeQuad(u))}n.sort();const N=this.createMessageDigest();for(const D of n)N.update(D);return a.hash=N.digest(),a.hash}hashRelatedBlankNode(t,n,a,b){let N;this.canonicalIssuer.hasId(t)?N=this.canonicalIssuer.getId(t):a.hasId(t)?N=a.getId(t):N=this.blankNodeInfo.get(t).hash;const D=this.createMessageDigest();return D.update(b),b!=="g"&&D.update(this.getRelatedPredicate(n)),D.update(N),D.digest()}hashNDegreeQuads(t,n){const a=this.deepIterations.get(t)||0;if(a>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,a+1);const b=this.createMessageDigest(),N=this.createHashToRelated(t,n),D=[...N.keys()].sort();for(const u of D){b.update(u);let l="",w;const _=new g(N.get(u));for(;_.hasNext();){const O=_.next();let H=n.clone(),k="";const f=[];let e=!1;for(const i of O)if(this.canonicalIssuer.hasId(i)?k+=this.canonicalIssuer.getId(i):(H.hasId(i)||f.push(i),k+=H.getId(i)),l.length!==0&&k>l){e=!0;break}if(!e){for(const i of f){const c=this.hashNDegreeQuads(i,H);if(k+=H.getId(i),k+=`<${c.hash}>`,H=c.issuer,l.length!==0&&k>l){e=!0;break}}e||(l.length===0||k<l)&&(l=k,w=H)}}b.update(l),n=w}return{hash:b.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const a=new Map,b=this.blankNodeInfo.get(t).quads;for(const N of b)this._addRelatedBlankNodeHash({quad:N,component:N.subject,position:"s",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:N,component:N.object,position:"o",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:N,component:N.graph,position:"g",id:t,issuer:n,hashToRelated:a});return a}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const a=this.hashFirstDegreeQuads(t),b=n.get(a);b?b.push(t):n.set(a,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const a=n.value,b=this.blankNodeInfo.get(a);b?b.quads.add(t):this.blankNodeInfo.set(a,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:a,id:b,issuer:N,hashToRelated:D}){if(!(n.termType==="BlankNode"&&n.value!==b))return;const u=n.value,l=this.hashRelatedBlankNode(u,t,N,a),w=D.get(l);w?w.push(u):D.set(l,[u])}_componentWithCanonicalId({component:t}){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}};function A(r,t){return r.hash<t.hash?-1:r.hash>t.hash?1:0}return xe}/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */var Ne,dt;function Zt(){if(dt)return Ne;dt=1;const v=ue(),s=Gt();return Ne=class extends s{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new v("sha1")}modifyFirstDegreeComponent(p,A,r){return A.termType!=="BlankNode"?A:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:A.value===p?"_:a":"_:z"}}getRelatedPredicate(p){return p.predicate.value}createHashToRelated(p,A){const r=new Map,t=this.blankNodeInfo.get(p).quads;for(const n of t){let a,b;if(n.subject.termType==="BlankNode"&&n.subject.value!==p)b=n.subject.value,a="p";else if(n.object.termType==="BlankNode"&&n.object.value!==p)b=n.object.value,a="r";else continue;const N=this.hashRelatedBlankNode(b,n,A,a),D=r.get(N);D?D.push(b):r.set(N,[b])}return r}},Ne}var ft;function en(){return ft||(ft=1,(function(v){const s=Vt(),g=Ct(),p=Gt(),A=Zt();let r;try{r=Kt}catch{}function t(n){return Array.isArray(n)?n:v.NQuads.legacyDatasetToQuads(n)}v.NQuads=Ze(),v.IdentifierIssuer=Ce(),v._rdfCanonizeNative=function(n){return n&&(r=n),r},v.canonize=async function(n,a){const b=t(n);if(a.useNative){if(!r)throw new Error("rdf-canonize-native not available");if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((N,D)=>r.canonize(b,a,(u,l)=>u?D(u):N(l)))}if(a.algorithm==="URDNA2015")return new s(a).main(b);if(a.algorithm==="URGNA2012"){if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new g(a).main(b)}throw"algorithm"in a?new Error("Invalid RDF Dataset Canonicalization algorithm: "+a.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},v._canonizeSync=function(n,a){const b=t(n);if(a.useNative){if(!r)throw new Error("rdf-canonize-native not available");if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return r.canonizeSync(b,a)}if(a.algorithm==="URDNA2015")return new p(a).main(b);if(a.algorithm==="URGNA2012"){if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new A(a).main(b)}throw"algorithm"in a?new Error("Invalid RDF Dataset Canonicalization algorithm: "+a.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}})(pe)),pe}var Ee,ht;function et(){return ht||(ht=1,Ee=en()),Ee}var _e,pt;function ee(){if(pt)return _e;pt=1;const v={};return _e=v,v.isArray=Array.isArray,v.isBoolean=s=>typeof s=="boolean"||Object.prototype.toString.call(s)==="[object Boolean]",v.isDouble=s=>v.isNumber(s)&&(String(s).indexOf(".")!==-1||Math.abs(s)>=1e21),v.isEmptyObject=s=>v.isObject(s)&&Object.keys(s).length===0,v.isNumber=s=>typeof s=="number"||Object.prototype.toString.call(s)==="[object Number]",v.isNumeric=s=>!isNaN(parseFloat(s))&&isFinite(s),v.isObject=s=>Object.prototype.toString.call(s)==="[object Object]",v.isString=s=>typeof s=="string"||Object.prototype.toString.call(s)==="[object String]",v.isUndefined=s=>typeof s>"u",_e}var je,gt;function re(){if(gt)return je;gt=1;const v=ee(),s={};return je=s,s.isSubject=g=>v.isObject(g)&&!("@value"in g||"@set"in g||"@list"in g)?Object.keys(g).length>1||!("@id"in g):!1,s.isSubjectReference=g=>v.isObject(g)&&Object.keys(g).length===1&&"@id"in g,s.isValue=g=>v.isObject(g)&&"@value"in g,s.isList=g=>v.isObject(g)&&"@list"in g,s.isGraph=g=>v.isObject(g)&&"@graph"in g&&Object.keys(g).filter(p=>p!=="@id"&&p!=="@index").length===1,s.isSimpleGraph=g=>s.isGraph(g)&&!("@id"in g),s.isBlankNode=g=>{if(v.isObject(g)){if("@id"in g){const p=g["@id"];return!v.isString(p)||p.indexOf("_:")===0}return Object.keys(g).length===0||!("@value"in g||"@set"in g||"@list"in g)}return!1},je}var Se,yt;function ne(){return yt||(yt=1,Se=class extends Error{constructor(s="An unspecified JSON-LD error occurred.",g="jsonld.Error",p={}){super(s),this.name=g,this.message=s,this.details=p}}),Se}var Re,vt;function te(){if(vt)return Re;vt=1;const v=re(),s=ee(),g=et().IdentifierIssuer,p=ne(),A=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,r=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,t=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,n=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,a=/^@[a-zA-Z]+$/,b={headers:{accept:"application/ld+json, application/json"}},N={};Re=N,N.IdentifierIssuer=g,N.REGEX_BCP47=A,N.REGEX_KEYWORD=a,N.clone=function(u){if(u&&typeof u=="object"){let l;if(s.isArray(u)){l=[];for(let w=0;w<u.length;++w)l[w]=N.clone(u[w])}else if(u instanceof Map){l=new Map;for(const[w,_]of u)l.set(w,N.clone(_))}else if(u instanceof Set){l=new Set;for(const w of u)l.add(N.clone(w))}else if(s.isObject(u)){l={};for(const w in u)l[w]=N.clone(u[w])}else l=u.toString();return l}return u},N.asArray=function(u){return Array.isArray(u)?u:[u]},N.buildHeaders=(u={})=>{if(Object.keys(u).some(w=>w.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+b.headers.accept+'" is supported.');return Object.assign({Accept:b.headers.accept},u)},N.parseLinkHeader=u=>{const l={},w=u.match(r);for(let _=0;_<w.length;++_){let O=w[_].match(t);if(!O)continue;const H={target:O[1]},k=O[2];for(;O=n.exec(k);)H[O[1]]=O[2]===void 0?O[3]:O[2];const f=H.rel||"";Array.isArray(l[f])?l[f].push(H):l.hasOwnProperty(f)?l[f]=[l[f],H]:l[f]=H}return l},N.validateTypeValue=(u,l)=>{if(!s.isString(u)&&!(s.isArray(u)&&u.every(w=>s.isString(w)))){if(l&&s.isObject(u))switch(Object.keys(u).length){case 0:return;case 1:if("@default"in u&&N.asArray(u["@default"]).every(w=>s.isString(w)))return}throw new p('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:u})}},N.hasProperty=(u,l)=>{if(u.hasOwnProperty(l)){const w=u[l];return!s.isArray(w)||w.length>0}return!1},N.hasValue=(u,l,w)=>{if(N.hasProperty(u,l)){let _=u[l];const O=v.isList(_);if(s.isArray(_)||O){O&&(_=_["@list"]);for(let H=0;H<_.length;++H)if(N.compareValues(w,_[H]))return!0}else if(!s.isArray(w))return N.compareValues(w,_)}return!1},N.addValue=(u,l,w,_)=>{if(_=_||{},"propertyIsArray"in _||(_.propertyIsArray=!1),"valueIsArray"in _||(_.valueIsArray=!1),"allowDuplicate"in _||(_.allowDuplicate=!0),"prependValue"in _||(_.prependValue=!1),_.valueIsArray)u[l]=w;else if(s.isArray(w)){w.length===0&&_.propertyIsArray&&!u.hasOwnProperty(l)&&(u[l]=[]),_.prependValue&&(w=w.concat(u[l]),u[l]=[]);for(let O=0;O<w.length;++O)N.addValue(u,l,w[O],_)}else if(u.hasOwnProperty(l)){const O=!_.allowDuplicate&&N.hasValue(u,l,w);!s.isArray(u[l])&&(!O||_.propertyIsArray)&&(u[l]=[u[l]]),O||(_.prependValue?u[l].unshift(w):u[l].push(w))}else u[l]=_.propertyIsArray?[w]:w},N.getValues=(u,l)=>[].concat(u[l]||[]),N.removeProperty=(u,l)=>{delete u[l]},N.removeValue=(u,l,w,_)=>{_=_||{},"propertyIsArray"in _||(_.propertyIsArray=!1);const O=N.getValues(u,l).filter(H=>!N.compareValues(H,w));O.length===0?N.removeProperty(u,l):O.length===1&&!_.propertyIsArray?u[l]=O[0]:u[l]=O},N.relabelBlankNodes=(u,l)=>{l=l||{};const w=l.issuer||new g("_:b");return D(w,u)},N.compareValues=(u,l)=>u===l||v.isValue(u)&&v.isValue(l)&&u["@value"]===l["@value"]&&u["@type"]===l["@type"]&&u["@language"]===l["@language"]&&u["@index"]===l["@index"]?!0:s.isObject(u)&&"@id"in u&&s.isObject(l)&&"@id"in l?u["@id"]===l["@id"]:!1,N.compareShortestLeast=(u,l)=>u.length<l.length?-1:l.length<u.length?1:u===l?0:u<l?-1:1;function D(u,l){if(s.isArray(l))for(let w=0;w<l.length;++w)l[w]=D(u,l[w]);else if(v.isList(l))l["@list"]=D(u,l["@list"]);else if(s.isObject(l)){v.isBlankNode(l)&&(l["@id"]=u.getId(l["@id"]));const w=Object.keys(l).sort();for(let _=0;_<w.length;++_){const O=w[_];O!=="@id"&&(l[O]=D(u,l[O]))}}return l}return Re}var De,mt;function tt(){if(mt)return De;mt=1;const v="http://www.w3.org/1999/02/22-rdf-syntax-ns#",s="http://www.w3.org/2001/XMLSchema#";return De={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:v,RDF_LIST:v+"List",RDF_FIRST:v+"first",RDF_REST:v+"rest",RDF_NIL:v+"nil",RDF_TYPE:v+"type",RDF_PLAIN_LITERAL:v+"PlainLiteral",RDF_XML_LITERAL:v+"XMLLiteral",RDF_JSON_LITERAL:v+"JSON",RDF_OBJECT:v+"object",RDF_LANGSTRING:v+"langString",XSD:s,XSD_BOOLEAN:s+"boolean",XSD_DOUBLE:s+"double",XSD_INTEGER:s+"integer",XSD_STRING:s+"string"},De}var Oe,bt;function zt(){return bt||(bt=1,Oe=class{constructor(){this._requests={}}wrapLoader(s){const g=this;return g._loader=s,function(){return g.add.apply(g,arguments)}}async add(s){let g=this._requests[s];if(g)return Promise.resolve(g);g=this._requests[s]=this._loader(s);try{return await g}finally{delete this._requests[s]}}}),Oe}var Le,wt;function ie(){if(wt)return Le;wt=1;const v=ee(),s={};Le=s,s.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},s.parse=(p,A)=>{const r={},t=s.parsers[A||"full"],n=t.regex.exec(p);let a=t.keys.length;for(;a--;)r[t.keys[a]]=n[a]===void 0?null:n[a];return(r.scheme==="https"&&r.port==="443"||r.scheme==="http"&&r.port==="80")&&(r.href=r.href.replace(":"+r.port,""),r.authority=r.authority.replace(":"+r.port,""),r.port=null),r.normalizedPath=s.removeDotSegments(r.path),r},s.prependBase=(p,A)=>{if(p===null||s.isAbsolute(A))return A;(!p||v.isString(p))&&(p=s.parse(p||""));const r=s.parse(A),t={protocol:p.protocol||""};if(r.authority!==null)t.authority=r.authority,t.path=r.path,t.query=r.query;else if(t.authority=p.authority,r.path==="")t.path=p.path,r.query!==null?t.query=r.query:t.query=p.query;else{if(r.path.indexOf("/")===0)t.path=r.path;else{let a=p.path;a=a.substr(0,a.lastIndexOf("/")+1),(a.length>0||p.authority)&&a.substr(-1)!=="/"&&(a+="/"),a+=r.path,t.path=a}t.query=r.query}r.path!==""&&(t.path=s.removeDotSegments(t.path));let n=t.protocol;return t.authority!==null&&(n+="//"+t.authority),n+=t.path,t.query!==null&&(n+="?"+t.query),r.fragment!==null&&(n+="#"+r.fragment),n===""&&(n="./"),n},s.removeBase=(p,A)=>{if(p===null)return A;(!p||v.isString(p))&&(p=s.parse(p||""));let r="";if(p.href!==""?r+=(p.protocol||"")+"//"+(p.authority||""):A.indexOf("//")&&(r+="//"),A.indexOf(r)!==0)return A;const t=s.parse(A.substr(r.length)),n=p.normalizedPath.split("/"),a=t.normalizedPath.split("/"),b=t.fragment||t.query?0:1;for(;n.length>0&&a.length>b&&n[0]===a[0];)n.shift(),a.shift();let N="";if(n.length>0){n.pop();for(let D=0;D<n.length;++D)N+="../"}return N+=a.join("/"),t.query!==null&&(N+="?"+t.query),t.fragment!==null&&(N+="#"+t.fragment),N===""&&(N="./"),N},s.removeDotSegments=p=>{if(p.length===0)return"";const A=p.split("/"),r=[];for(;A.length>0;){const t=A.shift(),n=A.length===0;if(t==="."){n&&r.push("");continue}if(t===".."){r.pop(),n&&r.push("");continue}r.push(t)}return p[0]==="/"&&r.length>0&&r[0]!==""&&r.unshift(""),r.length===1&&r[0]===""?"/":r.join("/")};const g=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;return s.isAbsolute=p=>v.isString(p)&&g.test(p),s.isRelative=p=>v.isString(p),Le}var Ae,It;function tn(){if(It)return Ae;It=1;const{parseLinkHeader:v,buildHeaders:s}=te(),{LINK_HEADER_CONTEXT:g}=tt(),p=ne(),A=zt(),{prependBase:r}=ie(),t=/(^|(\r\n))link:/i;Ae=({secure:a,headers:b={},xhr:N}={headers:{}})=>{return b=s(b),new A().wrapLoader(u);async function u(l){if(l.indexOf("http:")!==0&&l.indexOf("https:")!==0)throw new p('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:l});if(a&&l.indexOf("https")!==0)throw new p(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:l});let w;try{w=await n(N,l,b)}catch(f){throw new p("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:l,cause:f})}if(w.status>=400)throw new p("URL could not be dereferenced: "+w.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:l,httpStatusCode:w.status});let _={contextUrl:null,documentUrl:l,document:w.response},O=null;const H=w.getResponseHeader("Content-Type");let k;if(t.test(w.getAllResponseHeaders())&&(k=w.getResponseHeader("Link")),k&&H!=="application/ld+json"){const f=v(k),e=f[g];if(Array.isArray(e))throw new p("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:l});e&&(_.contextUrl=e.target),O=f.alternate,O&&O.type=="application/ld+json"&&!(H||"").match(/^application\/(\w*\+)?json$/)&&(_=await u(r(l,O.target)))}return _}};function n(a,b,N){a=a||XMLHttpRequest;const D=new a;return new Promise((u,l)=>{D.onload=()=>u(D),D.onerror=w=>l(w),D.open("GET",b,!0);for(const w in N)D.setRequestHeader(w,N[w]);D.send()})}return Ae}var Te,xt;function nn(){if(xt)return Te;xt=1;const v=tn(),s={};return Te=s,s.setupDocumentLoaders=function(g){typeof XMLHttpRequest<"u"&&(g.documentLoaders.xhr=v,g.useDocumentLoader("xhr"))},s.setupGlobals=function(g){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:g.JsonLdProcessor})},Te}var ke,Nt;function rn(){return Nt||(Nt=1,ke=function(v){v.prototype[Symbol.iterator]=function*(){for(let s=this.head;s;s=s.next)yield s.value}}),ke}var Me,Et;function sn(){if(Et)return Me;Et=1,Me=v,v.Node=A,v.create=v;function v(r){var t=this;if(t instanceof v||(t=new v),t.tail=null,t.head=null,t.length=0,r&&typeof r.forEach=="function")r.forEach(function(b){t.push(b)});else if(arguments.length>0)for(var n=0,a=arguments.length;n<a;n++)t.push(arguments[n]);return t}v.prototype.removeNode=function(r){if(r.list!==this)throw new Error("removing node which does not belong to this list");var t=r.next,n=r.prev;return t&&(t.prev=n),n&&(n.next=t),r===this.head&&(this.head=t),r===this.tail&&(this.tail=n),r.list.length--,r.next=null,r.prev=null,r.list=null,t},v.prototype.unshiftNode=function(r){if(r!==this.head){r.list&&r.list.removeNode(r);var t=this.head;r.list=this,r.next=t,t&&(t.prev=r),this.head=r,this.tail||(this.tail=r),this.length++}},v.prototype.pushNode=function(r){if(r!==this.tail){r.list&&r.list.removeNode(r);var t=this.tail;r.list=this,r.prev=t,t&&(t.next=r),this.tail=r,this.head||(this.head=r),this.length++}},v.prototype.push=function(){for(var r=0,t=arguments.length;r<t;r++)g(this,arguments[r]);return this.length},v.prototype.unshift=function(){for(var r=0,t=arguments.length;r<t;r++)p(this,arguments[r]);return this.length},v.prototype.pop=function(){if(this.tail){var r=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,r}},v.prototype.shift=function(){if(this.head){var r=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,r}},v.prototype.forEach=function(r,t){t=t||this;for(var n=this.head,a=0;n!==null;a++)r.call(t,n.value,a,this),n=n.next},v.prototype.forEachReverse=function(r,t){t=t||this;for(var n=this.tail,a=this.length-1;n!==null;a--)r.call(t,n.value,a,this),n=n.prev},v.prototype.get=function(r){for(var t=0,n=this.head;n!==null&&t<r;t++)n=n.next;if(t===r&&n!==null)return n.value},v.prototype.getReverse=function(r){for(var t=0,n=this.tail;n!==null&&t<r;t++)n=n.prev;if(t===r&&n!==null)return n.value},v.prototype.map=function(r,t){t=t||this;for(var n=new v,a=this.head;a!==null;)n.push(r.call(t,a.value,this)),a=a.next;return n},v.prototype.mapReverse=function(r,t){t=t||this;for(var n=new v,a=this.tail;a!==null;)n.push(r.call(t,a.value,this)),a=a.prev;return n},v.prototype.reduce=function(r,t){var n,a=this.head;if(arguments.length>1)n=t;else if(this.head)a=this.head.next,n=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var b=0;a!==null;b++)n=r(n,a.value,b),a=a.next;return n},v.prototype.reduceReverse=function(r,t){var n,a=this.tail;if(arguments.length>1)n=t;else if(this.tail)a=this.tail.prev,n=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var b=this.length-1;a!==null;b--)n=r(n,a.value,b),a=a.prev;return n},v.prototype.toArray=function(){for(var r=new Array(this.length),t=0,n=this.head;n!==null;t++)r[t]=n.value,n=n.next;return r},v.prototype.toArrayReverse=function(){for(var r=new Array(this.length),t=0,n=this.tail;n!==null;t++)r[t]=n.value,n=n.prev;return r},v.prototype.slice=function(r,t){t=t||this.length,t<0&&(t+=this.length),r=r||0,r<0&&(r+=this.length);var n=new v;if(t<r||t<0)return n;r<0&&(r=0),t>this.length&&(t=this.length);for(var a=0,b=this.head;b!==null&&a<r;a++)b=b.next;for(;b!==null&&a<t;a++,b=b.next)n.push(b.value);return n},v.prototype.sliceReverse=function(r,t){t=t||this.length,t<0&&(t+=this.length),r=r||0,r<0&&(r+=this.length);var n=new v;if(t<r||t<0)return n;r<0&&(r=0),t>this.length&&(t=this.length);for(var a=this.length,b=this.tail;b!==null&&a>t;a--)b=b.prev;for(;b!==null&&a>r;a--,b=b.prev)n.push(b.value);return n},v.prototype.splice=function(r,t,...n){r>this.length&&(r=this.length-1),r<0&&(r=this.length+r);for(var a=0,b=this.head;b!==null&&a<r;a++)b=b.next;for(var N=[],a=0;b&&a<t;a++)N.push(b.value),b=this.removeNode(b);b===null&&(b=this.tail),b!==this.head&&b!==this.tail&&(b=b.prev);for(var a=0;a<n.length;a++)b=s(this,b,n[a]);return N},v.prototype.reverse=function(){for(var r=this.head,t=this.tail,n=r;n!==null;n=n.prev){var a=n.prev;n.prev=n.next,n.next=a}return this.head=t,this.tail=r,this};function s(r,t,n){var a=t===r.head?new A(n,null,t,r):new A(n,t,t.next,r);return a.next===null&&(r.tail=a),a.prev===null&&(r.head=a),r.length++,a}function g(r,t){r.tail=new A(t,r.tail,null,r),r.head||(r.head=r.tail),r.length++}function p(r,t){r.head=new A(t,null,r.head,r),r.tail||(r.tail=r.head),r.length++}function A(r,t,n,a){if(!(this instanceof A))return new A(r,t,n,a);this.list=a,this.value=r,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}try{rn()(v)}catch{}return Me}var qe,_t;function $t(){if(_t)return qe;_t=1;const v=sn(),s=Symbol("max"),g=Symbol("length"),p=Symbol("lengthCalculator"),A=Symbol("allowStale"),r=Symbol("maxAge"),t=Symbol("dispose"),n=Symbol("noDisposeOnSet"),a=Symbol("lruList"),b=Symbol("cache"),N=Symbol("updateAgeOnGet"),D=()=>1;class u{constructor(e){if(typeof e=="number"&&(e={max:e}),e||(e={}),e.max&&(typeof e.max!="number"||e.max<0))throw new TypeError("max must be a non-negative number");this[s]=e.max||1/0;const i=e.length||D;if(this[p]=typeof i!="function"?D:i,this[A]=e.stale||!1,e.maxAge&&typeof e.maxAge!="number")throw new TypeError("maxAge must be a number");this[r]=e.maxAge||0,this[t]=e.dispose,this[n]=e.noDisposeOnSet||!1,this[N]=e.updateAgeOnGet||!1,this.reset()}set max(e){if(typeof e!="number"||e<0)throw new TypeError("max must be a non-negative number");this[s]=e||1/0,_(this)}get max(){return this[s]}set allowStale(e){this[A]=!!e}get allowStale(){return this[A]}set maxAge(e){if(typeof e!="number")throw new TypeError("maxAge must be a non-negative number");this[r]=e,_(this)}get maxAge(){return this[r]}set lengthCalculator(e){typeof e!="function"&&(e=D),e!==this[p]&&(this[p]=e,this[g]=0,this[a].forEach(i=>{i.length=this[p](i.value,i.key),this[g]+=i.length})),_(this)}get lengthCalculator(){return this[p]}get length(){return this[g]}get itemCount(){return this[a].length}rforEach(e,i){i=i||this;for(let c=this[a].tail;c!==null;){const j=c.prev;k(this,e,c,i),c=j}}forEach(e,i){i=i||this;for(let c=this[a].head;c!==null;){const j=c.next;k(this,e,c,i),c=j}}keys(){return this[a].toArray().map(e=>e.key)}values(){return this[a].toArray().map(e=>e.value)}reset(){this[t]&&this[a]&&this[a].length&&this[a].forEach(e=>this[t](e.key,e.value)),this[b]=new Map,this[a]=new v,this[g]=0}dump(){return this[a].map(e=>w(this,e)?!1:{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[a]}set(e,i,c){if(c=c||this[r],c&&typeof c!="number")throw new TypeError("maxAge must be a number");const j=c?Date.now():0,d=this[p](i,e);if(this[b].has(e)){if(d>this[s])return O(this,this[b].get(e)),!1;const J=this[b].get(e).value;return this[t]&&(this[n]||this[t](e,J.value)),J.now=j,J.maxAge=c,J.value=i,this[g]+=d-J.length,J.length=d,this.get(e),_(this),!0}const x=new H(e,i,d,j,c);return x.length>this[s]?(this[t]&&this[t](e,i),!1):(this[g]+=x.length,this[a].unshift(x),this[b].set(e,this[a].head),_(this),!0)}has(e){if(!this[b].has(e))return!1;const i=this[b].get(e).value;return!w(this,i)}get(e){return l(this,e,!0)}peek(e){return l(this,e,!1)}pop(){const e=this[a].tail;return e?(O(this,e),e.value):null}del(e){O(this,this[b].get(e))}load(e){this.reset();const i=Date.now();for(let c=e.length-1;c>=0;c--){const j=e[c],d=j.e||0;if(d===0)this.set(j.k,j.v);else{const x=d-i;x>0&&this.set(j.k,j.v,x)}}}prune(){this[b].forEach((e,i)=>l(this,i,!1))}}const l=(f,e,i)=>{const c=f[b].get(e);if(c){const j=c.value;if(w(f,j)){if(O(f,c),!f[A])return}else i&&(f[N]&&(c.value.now=Date.now()),f[a].unshiftNode(c));return j.value}},w=(f,e)=>{if(!e||!e.maxAge&&!f[r])return!1;const i=Date.now()-e.now;return e.maxAge?i>e.maxAge:f[r]&&i>f[r]},_=f=>{if(f[g]>f[s])for(let e=f[a].tail;f[g]>f[s]&&e!==null;){const i=e.prev;O(f,e),e=i}},O=(f,e)=>{if(e){const i=e.value;f[t]&&f[t](i.key,i.value),f[g]-=i.length,f[b].delete(i.key),f[a].removeNode(e)}};class H{constructor(e,i,c,j,d){this.key=e,this.value=i,this.length=c,this.now=j,this.maxAge=d||0}}const k=(f,e,i,c)=>{let j=i.value;w(f,j)&&(O(f,i),f[A]||(j=void 0)),j&&e.call(c,j.value,j.key,f)};return qe=u,qe}var Je,jt;function an(){if(jt)return Je;jt=1;const v=$t(),s=10;return Je=class{constructor({document:p}){this.document=p,this.cache=new v({max:s})}getProcessed(p){return this.cache.get(p)}setProcessed(p,A){this.cache.set(p,A)}},Je}var Fe,St;function on(){if(St)return Fe;St=1;const{isArray:v,isObject:s,isString:g}=ee(),{asArray:p}=te(),{prependBase:A}=ie(),r=ne(),t=an(),n=10;Fe=class{constructor({sharedCache:D}){this.perOpCache=new Map,this.sharedCache=D}async resolve({activeCtx:D,context:u,documentLoader:l,base:w,cycles:_=new Set}){u&&s(u)&&u["@context"]&&(u=u["@context"]),u=p(u);const O=[];for(const H of u){if(g(H)){let e=this._get(H);e||(e=await this._resolveRemoteContext({activeCtx:D,url:H,documentLoader:l,base:w,cycles:_})),v(e)?O.push(...e):O.push(e);continue}if(H===null){O.push(new t({document:null}));continue}s(H)||a(u);const k=JSON.stringify(H);let f=this._get(k);f||(f=new t({document:H}),this._cacheResolvedContext({key:k,resolved:f,tag:"static"})),O.push(f)}return O}_get(D){let u=this.perOpCache.get(D);if(!u){const l=this.sharedCache.get(D);l&&(u=l.get("static"),u&&this.perOpCache.set(D,u))}return u}_cacheResolvedContext({key:D,resolved:u,tag:l}){if(this.perOpCache.set(D,u),l!==void 0){let w=this.sharedCache.get(D);w||(w=new Map,this.sharedCache.set(D,w)),w.set(l,u)}return u}async _resolveRemoteContext({activeCtx:D,url:u,documentLoader:l,base:w,cycles:_}){u=A(w,u);const{context:O,remoteDoc:H}=await this._fetchContext({activeCtx:D,url:u,documentLoader:l,cycles:_});w=H.documentUrl||u,b({context:O,base:w});const k=await this.resolve({activeCtx:D,context:O,documentLoader:l,base:w,cycles:_});return this._cacheResolvedContext({key:u,resolved:k,tag:H.tag}),k}async _fetchContext({activeCtx:D,url:u,documentLoader:l,cycles:w}){if(w.size>n)throw new r("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:D.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:n});if(w.has(u))throw new r("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:D.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:u});w.add(u);let _,O;try{O=await l(u),_=O.document||null,g(_)&&(_=JSON.parse(_))}catch(H){throw new r(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${u}".`,"jsonld.InvalidUrl",{code:"loading remote context failed",url:u,cause:H})}if(!s(_))throw new r(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${u}".`,"jsonld.InvalidUrl",{code:"invalid remote context",url:u});return"@context"in _?_={"@context":_["@context"]}:_={"@context":{}},O.contextUrl&&(v(_["@context"])||(_["@context"]=[_["@context"]]),_["@context"].push(O.contextUrl)),{context:_,remoteDoc:O}}};function a(N){throw new r("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:N})}function b({context:N,base:D}){if(!N)return;const u=N["@context"];if(g(u)){N["@context"]=A(D,u);return}if(v(u)){for(let l=0;l<u.length;++l){const w=u[l];if(g(w)){u[l]=A(D,w);continue}s(w)&&b({context:{"@context":w},base:D})}return}if(s(u))for(const l in u)b({context:u[l],base:D})}return Fe}var He,Rt;function ln(){return Rt||(Rt=1,He=et().NQuads),He}var Ue,Dt;function ae(){if(Dt)return Ue;Dt=1;const v=ne(),{isArray:s}=ee(),{asArray:g}=te(),p={};Ue=p,p.defaultEventHandler=null,p.setupEventHandler=({options:t={}})=>{const n=[].concat(t.safe?p.safeEventHandler:[],t.eventHandler?g(t.eventHandler):[],p.defaultEventHandler?p.defaultEventHandler:[]);return n.length===0?null:n},p.handleEvent=({event:t,options:n})=>{A({event:t,handlers:n.eventHandler})};function A({event:t,handlers:n}){let a=!0;for(let b=0;a&&b<n.length;++b){a=!1;const N=n[b];if(s(N))a=A({event:t,handlers:N});else if(typeof N=="function")N({event:t,next:()=>{a=!0}});else if(typeof N=="object")t.code in N?N[t.code]({event:t,next:()=>{a=!0}}):a=!0;else throw new v("Invalid event handler.","jsonld.InvalidEventHandler",{event:t})}return a}const r=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);return p.safeEventHandler=function({event:n,next:a}){if(n.level==="warning"&&r.has(n.code))throw new v("Safe mode validation error.","jsonld.ValidationError",{event:n});a()},p.logEventHandler=function({event:n,next:a}){console.log(`EVENT: ${n.message}`,{event:n}),a()},p.logWarningEventHandler=function({event:n,next:a}){n.level==="warning"&&console.warn(`WARNING: ${n.message}`,{event:n}),a()},p.unhandledEventHandler=function({event:n}){throw new v("No handler for event.","jsonld.UnhandledEvent",{event:n})},p.setDefaultEventHandler=function({eventHandler:t}={}){p.defaultEventHandler=t?g(t):null},Ue}var Pe,Ot;function se(){if(Ot)return Pe;Ot=1;const v=te(),s=ne(),{isArray:g,isObject:p,isString:A,isUndefined:r}=ee(),{isAbsolute:t,isRelative:n,prependBase:a}=ie(),{handleEvent:b}=ae(),{REGEX_BCP47:N,REGEX_KEYWORD:D,asArray:u,compareShortestLeast:l}=te(),w=new Map,_=1e4,O={};Pe=O,O.process=async({activeCtx:f,localCtx:e,options:i,propagate:c=!0,overrideProtected:j=!1,cycles:d=new Set})=>{if(p(e)&&"@context"in e&&g(e["@context"])&&(e=e["@context"]),u(e).length===0)return f;const m=[],J=[({event:F,next:o})=>{m.push(F),o()}];i.eventHandler&&J.push(i.eventHandler);const M=i;i={...i,eventHandler:J};const E=await i.contextResolver.resolve({activeCtx:f,context:e,documentLoader:i.documentLoader,base:i.base});p(E[0].document)&&typeof E[0].document["@propagate"]=="boolean"&&(c=E[0].document["@propagate"]);let h=f;!c&&!h.previousContext&&(h=h.clone(),h.previousContext=f);for(const F of E){let{document:o}=F;if(f=h,o===null){if(!j&&Object.keys(f.protected).length!==0)throw new s("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});h=f=O.getInitialContext(i).clone();continue}const T=F.getProcessed(f);if(T){if(M.eventHandler)for(const q of T.events)b({event:q,options:M});h=f=T.context;continue}if(p(o)&&"@context"in o&&(o=o["@context"]),!p(o))throw new s("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:o});h=h.clone();const L=new Map;if("@version"in o){if(o["@version"]!==1.1)throw new s("Unsupported JSON-LD version: "+o["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:o});if(f.processingMode&&f.processingMode==="json-ld-1.0")throw new s("@version: "+o["@version"]+" not compatible with "+f.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:o});h.processingMode="json-ld-1.1",h["@version"]=o["@version"],L.set("@version",!0)}if(h.processingMode=h.processingMode||f.processingMode,"@base"in o){let q=o["@base"];if(!(q===null||t(q)))if(n(q))q=a(h["@base"],q);else throw new s('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:o});h["@base"]=q,L.set("@base",!0)}if("@vocab"in o){const q=o["@vocab"];if(q===null)delete h["@vocab"];else if(A(q)){if(!t(q)&&O.processingMode(h,1))throw new s('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:o});{const y=H(h,q,{vocab:!0,base:!0},void 0,void 0,i);t(y)||i.eventHandler&&b({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:y}},options:i}),h["@vocab"]=y}}else throw new s('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:o});L.set("@vocab",!0)}if("@language"in o){const q=o["@language"];if(q===null)delete h["@language"];else if(A(q))q.match(N)||i.eventHandler&&b({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:i}),h["@language"]=q.toLowerCase();else throw new s('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:o});L.set("@language",!0)}if("@direction"in o){const q=o["@direction"];if(f.processingMode==="json-ld-1.0")throw new s("Invalid JSON-LD syntax; @direction not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:o});if(q===null)delete h["@direction"];else{if(q!=="ltr"&&q!=="rtl")throw new s('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:o});h["@direction"]=q}L.set("@direction",!0)}if("@propagate"in o){const q=o["@propagate"];if(f.processingMode==="json-ld-1.0")throw new s("Invalid JSON-LD syntax; @propagate not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:o});if(typeof q!="boolean")throw new s("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:e});L.set("@propagate",!0)}if("@import"in o){const q=o["@import"];if(f.processingMode==="json-ld-1.0")throw new s("Invalid JSON-LD syntax; @import not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:o});if(!A(q))throw new s("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:e});const y=await i.contextResolver.resolve({activeCtx:f,context:q,documentLoader:i.documentLoader,base:i.base});if(y.length!==1)throw new s("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:e});const V=y[0].getProcessed(f);if(V)o=V;else{const U=y[0].document;if("@import"in U)throw new s("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:e});for(const G in U)o.hasOwnProperty(G)||(o[G]=U[G]);y[0].setProcessed(f,o)}L.set("@import",!0)}L.set("@protected",o["@protected"]||!1);for(const q in o)if(O.createTermDefinition({activeCtx:h,localCtx:o,term:q,defined:L,options:i,overrideProtected:j}),p(o[q])&&"@context"in o[q]){const y=o[q]["@context"];let V=!0;if(A(y)){const U=a(i.base,y);d.has(U)?V=!1:d.add(U)}if(V)try{await O.process({activeCtx:h.clone(),localCtx:o[q]["@context"],overrideProtected:!0,options:i,cycles:d})}catch{throw new s("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:o[q]["@context"],term:q})}}F.setProcessed(f,{context:h,events:m})}return h},O.createTermDefinition=({activeCtx:f,localCtx:e,term:i,defined:c,options:j,overrideProtected:d=!1})=>{if(c.has(i)){if(c.get(i))return;throw new s("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:e,term:i})}c.set(i,!1);let x;if(e.hasOwnProperty(i)&&(x=e[i]),i==="@type"&&p(x)&&(x["@container"]||"@set")==="@set"&&O.processingMode(f,1.1)){const o=["@container","@id","@protected"],T=Object.keys(x);if(T.length===0||T.some(L=>!o.includes(L)))throw new s("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:i})}else{if(O.isKeyword(i))throw new s("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:i});if(i.match(D)){j.eventHandler&&b({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:i}},options:j});return}else if(i==="")throw new s("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:e})}const m=f.mappings.get(i);f.mappings.has(i)&&f.mappings.delete(i);let J=!1;if((A(x)||x===null)&&(J=!0,x={"@id":x}),!p(x))throw new s("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:e});const M={};f.mappings.set(i,M),M.reverse=!1;const E=["@container","@id","@language","@reverse","@type"];O.processingMode(f,1.1)&&E.push("@context","@direction","@index","@nest","@prefix","@protected");for(const o in x)if(!E.includes(o))throw new s("Invalid JSON-LD syntax; a term definition must not contain "+o,"jsonld.SyntaxError",{code:"invalid term definition",context:e});const h=i.indexOf(":");if(M._termHasColon=h>0,"@reverse"in x){if("@id"in x)throw new s("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});if("@nest"in x)throw new s("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});const o=x["@reverse"];if(!A(o))throw new s("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(o.match(D)){j.eventHandler&&b({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:o}},options:j}),m?f.mappings.set(i,m):f.mappings.delete(i);return}const T=H(f,o,{vocab:!0,base:!1},e,c,j);if(!t(T))throw new s("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});M["@id"]=T,M.reverse=!0}else if("@id"in x){let o=x["@id"];if(o&&!A(o))throw new s("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(o===null)M["@id"]=null;else if(!O.isKeyword(o)&&o.match(D)){j.eventHandler&&b({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:o}},options:j}),m?f.mappings.set(i,m):f.mappings.delete(i);return}else if(o!==i){if(o=H(f,o,{vocab:!0,base:!1},e,c,j),!t(o)&&!O.isKeyword(o))throw new s("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(i.match(/(?::[^:])|\//)){const T=new Map(c).set(i,!0);if(H(f,i,{vocab:!0,base:!1},e,T,j)!==o)throw new s("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e})}M["@id"]=o,M._prefix=J&&!M._termHasColon&&o.match(/[:\/\?#\[\]@]$/)!==null}}if(!("@id"in M))if(M._termHasColon){const o=i.substr(0,h);if(e.hasOwnProperty(o)&&O.createTermDefinition({activeCtx:f,localCtx:e,term:o,defined:c,options:j}),f.mappings.has(o)){const T=i.substr(h+1);M["@id"]=f.mappings.get(o)["@id"]+T}else M["@id"]=i}else if(i==="@type")M["@id"]=i;else{if(!("@vocab"in f))throw new s("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e,term:i});M["@id"]=f["@vocab"]+i}if((x["@protected"]===!0||c.get("@protected")===!0&&x["@protected"]!==!1)&&(f.protected[i]=!0,M.protected=!0),c.set(i,!0),"@type"in x){let o=x["@type"];if(!A(o))throw new s("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(o==="@json"||o==="@none"){if(O.processingMode(f,1))throw new s(`Invalid JSON-LD syntax; an @context @type value must not be "${o}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else if(o!=="@id"&&o!=="@vocab"){if(o=H(f,o,{vocab:!0,base:!1},e,c,j),!t(o))throw new s("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(o.indexOf("_:")===0)throw new s("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}M["@type"]=o}if("@container"in x){const o=A(x["@container"])?[x["@container"]]:x["@container"]||[],T=["@list","@set","@index","@language"];let L=!0;const q=o.includes("@set");if(O.processingMode(f,1.1)){if(T.push("@graph","@id","@type"),o.includes("@list")){if(o.length!==1)throw new s("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else if(o.includes("@graph")){if(o.some(y=>y!=="@graph"&&y!=="@id"&&y!=="@index"&&y!=="@set"))throw new s("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else L&=o.length<=(q?2:1);if(o.includes("@type")&&(M["@type"]=M["@type"]||"@id",!["@id","@vocab"].includes(M["@type"])))throw new s("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else L&=!g(x["@container"]),L&=o.length<=1;if(L&=o.every(y=>T.includes(y)),L&=!(q&&o.includes("@list")),!L)throw new s("Invalid JSON-LD syntax; @context @container value must be one of the following: "+T.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:e});if(M.reverse&&!o.every(y=>["@index","@set"].includes(y)))throw new s("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});M["@container"]=o}if("@index"in x){if(!("@container"in x)||!M["@container"].includes("@index"))throw new s(`Invalid JSON-LD syntax; @index without @index in @container: "${x["@index"]}" on term "${i}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});if(!A(x["@index"])||x["@index"].indexOf("@")===0)throw new s(`Invalid JSON-LD syntax; @index must expand to an IRI: "${x["@index"]}" on term "${i}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});M["@index"]=x["@index"]}if("@context"in x&&(M["@context"]=x["@context"]),"@language"in x&&!("@type"in x)){let o=x["@language"];if(o!==null&&!A(o))throw new s("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:e});o!==null&&(o=o.toLowerCase()),M["@language"]=o}if("@prefix"in x){if(i.match(/:|\//))throw new s("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(O.isKeyword(M["@id"]))throw new s("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(typeof x["@prefix"]=="boolean")M._prefix=x["@prefix"]===!0;else throw new s("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:e})}if("@direction"in x){const o=x["@direction"];if(o!==null&&o!=="ltr"&&o!=="rtl")throw new s('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:e});M["@direction"]=o}if("@nest"in x){const o=x["@nest"];if(!A(o)||o!=="@nest"&&o.indexOf("@")===0)throw new s("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:e});M["@nest"]=o}// disallow aliasing @context and @preserve
const F=M["@id"];if(F==="@context"||F==="@preserve")throw new s("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:e});if(m&&m.protected&&!d&&(f.protected[i]=!0,M.protected=!0,!k(m,M)))throw new s("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:e,term:i})},O.expandIri=(f,e,i,c)=>H(f,e,i,void 0,void 0,c);function H(f,e,i,c,j,d){if(e===null||!A(e)||O.isKeyword(e))return e;if(e.match(D))return null;if(c&&c.hasOwnProperty(e)&&j.get(e)!==!0&&O.createTermDefinition({activeCtx:f,localCtx:c,term:e,defined:j,options:d}),i=i||{},i.vocab){const m=f.mappings.get(e);if(m===null)return null;if(p(m)&&"@id"in m)return m["@id"]}const x=e.indexOf(":");if(x>0){const m=e.substr(0,x),J=e.substr(x+1);if(m==="_"||J.indexOf("//")===0)return e;c&&c.hasOwnProperty(m)&&O.createTermDefinition({activeCtx:f,localCtx:c,term:m,defined:j,options:d});const M=f.mappings.get(m);if(M&&M._prefix)return M["@id"]+J;if(t(e))return e}if(i.vocab&&"@vocab"in f)e=f["@vocab"]+e;else if(i.base){let m,J;"@base"in f?f["@base"]?(J=a(d.base,f["@base"]),m=a(J,e)):(J=f["@base"],m=e):(J=d.base,m=a(d.base,e)),e=m}return e}O.getInitialContext=f=>{const e=JSON.stringify({processingMode:f.processingMode}),i=w.get(e);if(i)return i;const c={processingMode:f.processingMode,mappings:new Map,inverse:null,getInverse:j,clone:m,revertToPreviousContext:J,protected:{}};return w.size===_&&w.clear(),w.set(e,c),c;function j(){const M=this;if(M.inverse)return M.inverse;const E=M.inverse={},h=M.fastCurieMap={},F={},o=(M["@language"]||"@none").toLowerCase(),T=M["@direction"],L=M.mappings,q=[...L.keys()].sort(l);for(const y of q){const V=L.get(y);if(V===null)continue;let U=V["@container"]||"@none";if(U=[].concat(U).sort().join(""),V["@id"]===null)continue;const G=u(V["@id"]);for(const X of G){let R=E[X];const I=O.isKeyword(X);if(R)!I&&!V._termHasColon&&F[X].push(y);else if(E[X]=R={},!I&&!V._termHasColon){F[X]=[y];const S={iri:X,terms:F[X]};X[0]in h?h[X[0]].push(S):h[X[0]]=[S]}if(R[U]||(R[U]={"@language":{},"@type":{},"@any":{}}),R=R[U],x(y,R["@any"],"@none"),V.reverse)x(y,R["@type"],"@reverse");else if(V["@type"]==="@none")x(y,R["@any"],"@none"),x(y,R["@language"],"@none"),x(y,R["@type"],"@none");else if("@type"in V)x(y,R["@type"],V["@type"]);else if("@language"in V&&"@direction"in V){const S=V["@language"],B=V["@direction"];S&&B?x(y,R["@language"],`${S}_${B}`.toLowerCase()):S?x(y,R["@language"],S.toLowerCase()):B?x(y,R["@language"],`_${B}`):x(y,R["@language"],"@null")}else"@language"in V?x(y,R["@language"],(V["@language"]||"@null").toLowerCase()):"@direction"in V?V["@direction"]?x(y,R["@language"],`_${V["@direction"]}`):x(y,R["@language"],"@none"):T?(x(y,R["@language"],`_${T}`),x(y,R["@language"],"@none"),x(y,R["@type"],"@none")):(x(y,R["@language"],o),x(y,R["@language"],"@none"),x(y,R["@type"],"@none"))}}for(const y in h)d(h,y,1);return E}function d(M,E,h){const F=M[E],o=M[E]={};let T,L;for(const q of F)T=q.iri,h>=T.length?L="":L=T[h],L in o?o[L].push(q):o[L]=[q];for(const q in o)q!==""&&d(o,q,h+1)}function x(M,E,h){E.hasOwnProperty(h)||(E[h]=M)}function m(){const M={};return M.mappings=v.clone(this.mappings),M.clone=this.clone,M.inverse=null,M.getInverse=this.getInverse,M.protected=v.clone(this.protected),this.previousContext&&(M.previousContext=this.previousContext.clone()),M.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(M["@base"]=this["@base"]),"@language"in this&&(M["@language"]=this["@language"]),"@vocab"in this&&(M["@vocab"]=this["@vocab"]),M}function J(){return this.previousContext?this.previousContext.clone():this}},O.getContextValue=(f,e,i)=>{if(e===null)return i==="@context"?void 0:null;if(f.mappings.has(e)){const c=f.mappings.get(e);if(r(i))return c;if(c.hasOwnProperty(i))return c[i]}if(i==="@language"&&i in f||i==="@direction"&&i in f)return f[i];if(i!=="@context")return null},O.processingMode=(f,e)=>e.toString()>="1.1"?!f.processingMode||f.processingMode>="json-ld-"+e.toString():f.processingMode==="json-ld-1.0",O.isKeyword=f=>{if(!A(f)||f[0]!=="@")return!1;switch(f){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function k(f,e){if(!(f&&typeof f=="object")||!(e&&typeof e=="object"))return f===e;const i=Array.isArray(f);if(i!==Array.isArray(e))return!1;if(i){if(f.length!==e.length)return!1;for(let d=0;d<f.length;++d)if(!k(f[d],e[d]))return!1;return!0}const c=Object.keys(f),j=Object.keys(e);if(c.length!==j.length)return!1;for(const d in f){let x=f[d],m=e[d];if(d==="@container"&&Array.isArray(x)&&Array.isArray(m)&&(x=x.slice().sort(),m=m.slice().sort()),!k(x,m))return!1}return!0}return Pe}var Be,Lt;function cn(){if(Lt)return Be;Lt=1;const v=ne(),{isArray:s,isObject:g,isEmptyObject:p,isString:A,isUndefined:r}=ee(),{isList:t,isValue:n,isGraph:a,isSubject:b}=re(),{expandIri:N,getContextValue:D,isKeyword:u,process:l,processingMode:w}=se(),{isAbsolute:_}=ie(),{REGEX_BCP47:O,REGEX_KEYWORD:H,addValue:k,asArray:f,getValues:e,validateTypeValue:i}=te(),{handleEvent:c}=ae(),j={};Be=j,j.expand=async({activeCtx:E,activeProperty:h=null,element:F,options:o={},insideList:T=!1,insideIndex:L=!1,typeScopedContext:q=null})=>{if(F==null)return null;if(h==="@default"&&(o=Object.assign({},o,{isFrame:!1})),!s(F)&&!g(F))return!T&&(h===null||N(E,h,{vocab:!0},o)==="@graph")?(o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:F}},options:o}),null):m({activeCtx:E,activeProperty:h,value:F,options:o});if(s(F)){let S=[];const B=D(E,h,"@container")||[];T=T||B.includes("@list");for(let $=0;$<F.length;++$){let P=await j.expand({activeCtx:E,activeProperty:h,element:F[$],options:o,insideIndex:L,typeScopedContext:q});T&&s(P)&&(P={"@list":P}),P!==null&&(s(P)?S=S.concat(P):S.push(P))}return S}const y=N(E,h,{vocab:!0},o),V=D(E,h,"@context");q=q||(E.previousContext?E:null);let U=Object.keys(F).sort(),G=!L;if(G&&q&&U.length<=2&&!U.includes("@context"))for(const S of U){const B=N(q,S,{vocab:!0},o);if(B==="@value"){G=!1,E=q;break}if(B==="@id"&&U.length===1){G=!1;break}}G&&(E=E.revertToPreviousContext()),r(V)||(E=await l({activeCtx:E,localCtx:V,propagate:!0,overrideProtected:!0,options:o})),"@context"in F&&(E=await l({activeCtx:E,localCtx:F["@context"],options:o})),q=E;let X=null;for(const S of U)if(N(E,S,{vocab:!0},o)==="@type"){X=X||S;const $=F[S],P=Array.isArray($)?$.length>1?$.slice().sort():$:[$];for(const Q of P){const W=D(q,Q,"@context");r(W)||(E=await l({activeCtx:E,localCtx:W,options:o,propagate:!1}))}}let R={};await x({activeCtx:E,activeProperty:h,expandedActiveProperty:y,element:F,expandedParent:R,options:o,insideList:T,typeKey:X,typeScopedContext:q}),U=Object.keys(R);let I=U.length;if("@value"in R){if("@type"in R&&("@language"in R||"@direction"in R))throw new v('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:R});let S=I-1;if("@type"in R&&(S-=1),"@index"in R&&(S-=1),"@language"in R&&(S-=1),"@direction"in R&&(S-=1),S!==0)throw new v('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:R});const B=R["@value"]===null?[]:f(R["@value"]),$=e(R,"@type");if(!(w(E,1.1)&&$.includes("@json")&&$.length===1))if(B.length===0)o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:R}},options:o}),R=null;else{if(!B.every(P=>A(P)||p(P))&&"@language"in R)throw new v("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:R});if(!$.every(P=>_(P)&&!(A(P)&&P.indexOf("_:")===0)||p(P)))throw new v('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:R})}}else if("@type"in R&&!s(R["@type"]))R["@type"]=[R["@type"]];else if("@set"in R||"@list"in R){if(I>1&&!(I===2&&"@index"in R))throw new v('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:R});"@set"in R&&(R=R["@set"],U=Object.keys(R),I=U.length)}else I===1&&"@language"in R&&(o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:R}},options:o}),R=null);return g(R)&&!o.keepFreeFloatingNodes&&!T&&(h===null||y==="@graph"||(D(E,h,"@container")||[]).includes("@graph"))&&(R=d({value:R,count:I,options:o})),R};function d({value:E,count:h,options:F}){if(h===0||"@value"in E||"@list"in E||h===1&&"@id"in E){if(F.eventHandler){let o,T;h===0?(o="empty object",T="Dropping empty object."):"@value"in E?(o="object with only @value",T="Dropping object with only @value."):"@list"in E?(o="object with only @list",T="Dropping object with only @list."):h===1&&"@id"in E&&(o="object with only @id",T="Dropping object with only @id."),c({event:{type:["JsonLdEvent"],code:o,level:"warning",message:T,details:{value:E}},options:F})}return null}return E}async function x({activeCtx:E,activeProperty:h,expandedActiveProperty:F,element:o,expandedParent:T,options:L={},insideList:q,typeKey:y,typeScopedContext:V}){const U=Object.keys(o).sort(),G=[];let X;const R=o[y]&&N(E,s(o[y])?o[y][0]:o[y],{vocab:!0},{...L,typeExpansion:!0})==="@json";for(const I of U){let S=o[I],B;if(I==="@context")continue;const $=N(E,I,{vocab:!0},L);if($===null||!(_($)||u($))){L.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:I,expandedProperty:$}},options:L});continue}if(u($)){if(F==="@reverse")throw new v("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:S});if($ in T&&$!=="@included"&&$!=="@type")throw new v("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:$})}if($==="@id"){if(!A(S)){if(!L.isFrame)throw new v('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:S});if(g(S)){if(!p(S))throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:S})}else if(s(S)){if(!S.every(z=>A(z)))throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:S})}else throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:S})}k(T,"@id",f(S).map(z=>{if(A(z)){const K=N(E,z,{base:!0},L);return L.eventHandler&&(K===null?c(z===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:z}},options:L}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:z}},options:L}):_(K)||c({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:z,expandedId:K}},options:L})),K}return z}),{propertyIsArray:L.isFrame});continue}if($==="@type"){g(S)&&(S=Object.fromEntries(Object.entries(S).map(([z,K])=>[N(V,z,{vocab:!0}),f(K).map(C=>N(V,C,{base:!0,vocab:!0},{...L,typeExpansion:!0}))]))),i(S,L.isFrame),k(T,"@type",f(S).map(z=>{if(A(z)){const K=N(V,z,{base:!0,vocab:!0},{...L,typeExpansion:!0});return K!=="@json"&&!_(K)&&L.eventHandler&&c({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:z}},options:L}),K}return z}),{propertyIsArray:!!L.isFrame});continue}if($==="@included"&&w(E,1.1)){const z=f(await j.expand({activeCtx:E,activeProperty:h,element:S,options:L}));if(!z.every(K=>b(K)))throw new v("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:S});k(T,"@included",z,{propertyIsArray:!0});continue}if($==="@graph"&&!(g(S)||s(S)))throw new v('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:S});if($==="@value"){X=S,R&&w(E,1.1)?T["@value"]=S:k(T,"@value",S,{propertyIsArray:L.isFrame});continue}if($==="@language"){if(S===null)continue;if(!A(S)&&!L.isFrame)throw new v('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:S});S=f(S).map(z=>A(z)?z.toLowerCase():z);for(const z of S)A(z)&&!z.match(O)&&L.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:z}},options:L});k(T,"@language",S,{propertyIsArray:L.isFrame});continue}if($==="@direction"){if(!A(S)&&!L.isFrame)throw new v('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:S});S=f(S);for(const z of S)if(A(z)&&z!=="ltr"&&z!=="rtl")throw new v('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:S});k(T,"@direction",S,{propertyIsArray:L.isFrame});continue}if($==="@index"){if(!A(S))throw new v('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:S});k(T,"@index",S);continue}if($==="@reverse"){if(!g(S))throw new v('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:S});if(B=await j.expand({activeCtx:E,activeProperty:"@reverse",element:S,options:L}),"@reverse"in B)for(const K in B["@reverse"])k(T,K,B["@reverse"][K],{propertyIsArray:!0});let z=T["@reverse"]||null;for(const K in B){if(K==="@reverse")continue;z===null&&(z=T["@reverse"]={}),k(z,K,[],{propertyIsArray:!0});const C=B[K];for(let Y=0;Y<C.length;++Y){const Z=C[Y];if(n(Z)||t(Z))throw new v('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:B});k(z,K,Z,{propertyIsArray:!0})}}continue}if($==="@nest"){G.push(I);continue}let P=E;const Q=D(E,I,"@context");r(Q)||(P=await l({activeCtx:E,localCtx:Q,propagate:!0,overrideProtected:!0,options:L}));const W=D(E,I,"@container")||[];if(W.includes("@language")&&g(S)){const z=D(P,I,"@direction");B=J(P,S,z,L)}else if(W.includes("@index")&&g(S)){const z=W.includes("@graph"),K=D(P,I,"@index")||"@index",C=K!=="@index"&&N(E,K,{vocab:!0},L);B=await M({activeCtx:P,options:L,activeProperty:I,value:S,asGraph:z,indexKey:K,propertyIndex:C})}else if(W.includes("@id")&&g(S)){const z=W.includes("@graph");B=await M({activeCtx:P,options:L,activeProperty:I,value:S,asGraph:z,indexKey:"@id"})}else if(W.includes("@type")&&g(S))B=await M({activeCtx:P.revertToPreviousContext(),options:L,activeProperty:I,value:S,asGraph:!1,indexKey:"@type"});else{const z=$==="@list";if(z||$==="@set"){let K=h;z&&F==="@graph"&&(K=null),B=await j.expand({activeCtx:P,activeProperty:K,element:S,options:L,insideList:z})}else D(E,I,"@type")==="@json"?B={"@type":"@json","@value":S}:B=await j.expand({activeCtx:P,activeProperty:I,element:S,options:L,insideList:!1})}if(!(B===null&&$!=="@value")){if($!=="@list"&&!t(B)&&W.includes("@list")&&(B={"@list":f(B)}),W.includes("@graph")&&!W.some(z=>z==="@id"||z==="@index")){if(B=f(B),L.isFrame||(B=B.filter(z=>{const K=Object.keys(z).length;return d({value:z,count:K,options:L})!==null})),B.length===0)continue;B=B.map(z=>({"@graph":f(z)}))}if(P.mappings.has(I)&&P.mappings.get(I).reverse){const z=T["@reverse"]=T["@reverse"]||{};B=f(B);for(let K=0;K<B.length;++K){const C=B[K];if(n(C)||t(C))throw new v('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:B});k(z,$,C,{propertyIsArray:!0})}continue}k(T,$,B,{propertyIsArray:!0})}}if("@value"in T&&!(T["@type"]==="@json"&&w(E,1.1))){if((g(X)||s(X))&&!L.isFrame)throw new v('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:X})}for(const I of G){const S=s(o[I])?o[I]:[o[I]];for(const B of S){if(!g(B)||Object.keys(B).some($=>N(E,$,{vocab:!0},L)==="@value"))throw new v("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:B});await x({activeCtx:E,activeProperty:h,expandedActiveProperty:F,element:B,expandedParent:T,options:L,insideList:q,typeScopedContext:V,typeKey:y})}}}function m({activeCtx:E,activeProperty:h,value:F,options:o}){if(F==null)return null;const T=N(E,h,{vocab:!0},o);if(T==="@id")return N(E,F,{base:!0},o);if(T==="@type")return N(E,F,{vocab:!0,base:!0},{...o,typeExpansion:!0});const L=D(E,h,"@type");if((L==="@id"||T==="@graph")&&A(F)){const y=N(E,F,{base:!0},o);return y===null&&F.match(H)&&o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:h}},options:o}),{"@id":y}}if(L==="@vocab"&&A(F))return{"@id":N(E,F,{vocab:!0,base:!0},o)};if(u(T))return F;const q={};if(L&&!["@id","@vocab","@none"].includes(L))q["@type"]=L;else if(A(F)){const y=D(E,h,"@language");y!==null&&(q["@language"]=y);const V=D(E,h,"@direction");V!==null&&(q["@direction"]=V)}return["boolean","number","string"].includes(typeof F)||(F=F.toString()),q["@value"]=F,q}function J(E,h,F,o){const T=[],L=Object.keys(h).sort();for(const q of L){const y=N(E,q,{vocab:!0},o);let V=h[q];s(V)||(V=[V]);for(const U of V){if(U===null)continue;if(!A(U))throw new v("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:h});const G={"@value":U};y!=="@none"&&(q.match(O)||o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:o}),G["@language"]=q.toLowerCase()),F&&(G["@direction"]=F),T.push(G)}}return T}async function M({activeCtx:E,options:h,activeProperty:F,value:o,asGraph:T,indexKey:L,propertyIndex:q}){const y=[],V=Object.keys(o).sort(),U=L==="@type";for(let G of V){if(U){const I=D(E,G,"@context");r(I)||(E=await l({activeCtx:E,localCtx:I,propagate:!1,options:h}))}let X=o[G];s(X)||(X=[X]),X=await j.expand({activeCtx:E,activeProperty:F,element:X,options:h,insideList:!1,insideIndex:!0});let R;q?G==="@none"?R="@none":R=m({activeCtx:E,activeProperty:L,value:G,options:h}):R=N(E,G,{vocab:!0},h),L==="@id"?G=N(E,G,{base:!0},h):U&&(G=R);for(let I of X){if(T&&!a(I)&&(I={"@graph":[I]}),L==="@type")R==="@none"||(I["@type"]?I["@type"]=[G].concat(I["@type"]):I["@type"]=[G]);else{if(n(I)&&!["@language","@type","@index"].includes(L))throw new v(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${L}".`,"jsonld.SyntaxError",{code:"invalid value object",value:I});q?R!=="@none"&&k(I,q,R,{propertyIsArray:!0,prependValue:!0}):R!=="@none"&&!(L in I)&&(I[L]=G)}y.push(I)}}return y}return Be}var Ve,At;function de(){if(At)return Ve;At=1;const{isKeyword:v}=se(),s=re(),g=ee(),p=te(),A=ne(),r={};return Ve=r,r.createMergedNodeMap=(t,n)=>{n=n||{};const a=n.issuer||new p.IdentifierIssuer("_:b"),b={"@default":{}};return r.createNodeMap(t,b,"@default",a),r.mergeNodeMaps(b)},r.createNodeMap=(t,n,a,b,N,D)=>{if(g.isArray(t)){for(const _ of t)r.createNodeMap(_,n,a,b,void 0,D);return}if(!g.isObject(t)){D&&D.push(t);return}if(s.isValue(t)){if("@type"in t){let _=t["@type"];_.indexOf("_:")===0&&(t["@type"]=_=b.getId(_))}D&&D.push(t);return}else if(D&&s.isList(t)){const _=[];r.createNodeMap(t["@list"],n,a,b,N,_),D.push({"@list":_});return}if("@type"in t){const _=t["@type"];for(const O of _)O.indexOf("_:")===0&&b.getId(O)}g.isUndefined(N)&&(N=s.isBlankNode(t)?b.getId(t["@id"]):t["@id"]),D&&D.push({"@id":N});const u=n[a],l=u[N]=u[N]||{};l["@id"]=N;const w=Object.keys(t).sort();for(let _ of w){if(_==="@id")continue;if(_==="@reverse"){const H={"@id":N},k=t["@reverse"];for(const f in k){const e=k[f];for(const i of e){let c=i["@id"];s.isBlankNode(i)&&(c=b.getId(c)),r.createNodeMap(i,n,a,b,c),p.addValue(u[c],f,H,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(_==="@graph"){N in n||(n[N]={}),r.createNodeMap(t[_],n,N,b);continue}if(_==="@included"){r.createNodeMap(t[_],n,a,b);continue}if(_!=="@type"&&v(_)){if(_==="@index"&&_ in l&&(t[_]!==l[_]||t[_]["@id"]!==l[_]["@id"]))throw new A("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:l});l[_]=t[_];continue}const O=t[_];if(_.indexOf("_:")===0&&(_=b.getId(_)),O.length===0){p.addValue(l,_,[],{propertyIsArray:!0});continue}for(let H of O)if(_==="@type"&&(H=H.indexOf("_:")===0?b.getId(H):H),s.isSubject(H)||s.isSubjectReference(H)){if("@id"in H&&!H["@id"])continue;const k=s.isBlankNode(H)?b.getId(H["@id"]):H["@id"];p.addValue(l,_,{"@id":k},{propertyIsArray:!0,allowDuplicate:!1}),r.createNodeMap(H,n,a,b,k)}else if(s.isValue(H))p.addValue(l,_,H,{propertyIsArray:!0,allowDuplicate:!1});else if(s.isList(H)){const k=[];r.createNodeMap(H["@list"],n,a,b,N,k),H={"@list":k},p.addValue(l,_,H,{propertyIsArray:!0,allowDuplicate:!1})}else r.createNodeMap(H,n,a,b,N),p.addValue(l,_,H,{propertyIsArray:!0,allowDuplicate:!1})}},r.mergeNodeMapGraphs=t=>{const n={};for(const a of Object.keys(t).sort())for(const b of Object.keys(t[a]).sort()){const N=t[a][b];b in n||(n[b]={"@id":b});const D=n[b];for(const u of Object.keys(N).sort())if(v(u)&&u!=="@type")D[u]=p.clone(N[u]);else for(const l of N[u])p.addValue(D,u,p.clone(l),{propertyIsArray:!0,allowDuplicate:!1})}return n},r.mergeNodeMaps=t=>{const n=t["@default"],a=Object.keys(t).sort();for(const b of a){if(b==="@default")continue;const N=t[b];let D=n[b];D?"@graph"in D||(D["@graph"]=[]):n[b]=D={"@id":b,"@graph":[]};const u=D["@graph"];for(const l of Object.keys(N).sort()){const w=N[l];s.isSubjectReference(w)||u.push(w)}}return n},Ve}var Ge,Tt;function un(){if(Tt)return Ge;Tt=1;const{isSubjectReference:v}=re(),{createMergedNodeMap:s}=de(),g={};return Ge=g,g.flatten=p=>{const A=s(p),r=[],t=Object.keys(A).sort();for(let n=0;n<t.length;++n){const a=A[t[n]];v(a)||r.push(a)}return r},Ge}var ze,kt;function dn(){if(kt)return ze;kt=1;const v=ne(),s=re(),g=ee(),{REGEX_BCP47:p,addValue:A}=te(),{handleEvent:r}=ae(),{RDF_LIST:t,RDF_FIRST:n,RDF_REST:a,RDF_NIL:b,RDF_TYPE:N,RDF_JSON_LITERAL:D,XSD_BOOLEAN:u,XSD_DOUBLE:l,XSD_INTEGER:w,XSD_STRING:_}=tt(),O={};ze=O,O.fromRDF=async(k,f)=>{const{useRdfType:e=!1,useNativeTypes:i=!1,rdfDirection:c=null}=f,j={},d={"@default":j},x={};if(c){if(c==="compound-literal")throw new v("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:c});if(c!=="i18n-datatype")throw new v("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:c})}for(const M of k){const E=M.graph.termType==="DefaultGraph"?"@default":M.graph.value;E in d||(d[E]={}),E!=="@default"&&!(E in j)&&(j[E]={"@id":E});const h=d[E],F=M.subject.value,o=M.predicate.value,T=M.object;F in h||(h[F]={"@id":F});const L=h[F],q=T.termType.endsWith("Node");if(q&&!(T.value in h)&&(h[T.value]={"@id":T.value}),o===N&&!e&&q){A(L,"@type",T.value,{propertyIsArray:!0});continue}const y=H(T,i,c,f);if(A(L,o,y,{propertyIsArray:!0}),q)if(T.value===b){const V=h[T.value];"usages"in V||(V.usages=[]),V.usages.push({node:L,property:o,value:y})}else T.value in x?x[T.value]=!1:x[T.value]={node:L,property:o,value:y}}for(const M in d){const E=d[M];if(!(b in E))continue;const h=E[b];if(h.usages){for(let F of h.usages){let o=F.node,T=F.property,L=F.value;const q=[],y=[];let V=Object.keys(o).length;for(;T===a&&g.isObject(x[o["@id"]])&&g.isArray(o[n])&&o[n].length===1&&g.isArray(o[a])&&o[a].length===1&&(V===3||V===4&&g.isArray(o["@type"])&&o["@type"].length===1&&o["@type"][0]===t)&&(q.push(o[n][0]),y.push(o["@id"]),F=x[o["@id"]],o=F.node,T=F.property,L=F.value,V=Object.keys(o).length,!!s.isBlankNode(o)););delete L["@id"],L["@list"]=q.reverse();for(const U of y)delete E[U]}delete h.usages}}const m=[],J=Object.keys(j).sort();for(const M of J){const E=j[M];if(M in d){const h=E["@graph"]=[],F=d[M],o=Object.keys(F).sort();for(const T of o){const L=F[T];s.isSubjectReference(L)||h.push(L)}}s.isSubjectReference(E)||m.push(E)}return m};function H(k,f,e,i){if(k.termType.endsWith("Node"))return{"@id":k.value};const c={"@value":k.value};if(k.language)k.language.match(p)||i.eventHandler&&r({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:k.language}},options:i}),c["@language"]=k.language;else{let j=k.datatype.value;if(j||(j=_),j===D){j="@json";try{c["@value"]=JSON.parse(c["@value"])}catch(d){throw new v("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:c["@value"],cause:d})}}if(f){if(j===u)c["@value"]==="true"?c["@value"]=!0:c["@value"]==="false"&&(c["@value"]=!1);else if(g.isNumeric(c["@value"]))if(j===w){const d=parseInt(c["@value"],10);d.toFixed(0)===c["@value"]&&(c["@value"]=d)}else j===l&&(c["@value"]=parseFloat(c["@value"]));[u,w,l,_].includes(j)||(c["@type"]=j)}else if(e==="i18n-datatype"&&j.startsWith("https://www.w3.org/ns/i18n#")){const[,d,x]=j.split(/[#_]/);d.length>0&&(c["@language"]=d,d.match(p)||i.eventHandler&&r({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:d}},options:i})),c["@direction"]=x}else j!==_&&(c["@type"]=j)}return c}return ze}var $e,Mt;function fn(){return Mt||(Mt=1,$e=function v(s){return s===null||typeof s!="object"||s.toJSON!=null?JSON.stringify(s):Array.isArray(s)?"["+s.reduce((g,p,A)=>{const r=A===0?"":",",t=p===void 0||typeof p=="symbol"?null:p;return g+r+v(t)},"")+"]":"{"+Object.keys(s).sort().reduce((g,p,A)=>{if(s[p]===void 0||typeof s[p]=="symbol")return g;const r=g.length===0?"":",";return g+r+v(p)+":"+v(s[p])},"")+"}"}),$e}var Xe,qt;function hn(){if(qt)return Xe;qt=1;const{createNodeMap:v}=de(),{isKeyword:s}=se(),g=re(),p=fn(),A=ne(),r=ee(),t=te(),{handleEvent:n}=ae(),{RDF_FIRST:a,RDF_REST:b,RDF_NIL:N,RDF_TYPE:D,RDF_JSON_LITERAL:u,RDF_LANGSTRING:l,XSD_BOOLEAN:w,XSD_DOUBLE:_,XSD_INTEGER:O,XSD_STRING:H}=tt(),{isAbsolute:k}=ie(),f={};Xe=f,f.toRDF=(j,d)=>{const x=new t.IdentifierIssuer("_:b"),m={"@default":{}};v(j,m,"@default",x);const J=[],M=Object.keys(m).sort();for(const E of M){let h;if(E==="@default")h={termType:"DefaultGraph",value:""};else if(k(E))E.startsWith("_:")?h={termType:"BlankNode"}:h={termType:"NamedNode"},h.value=E;else{d.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:E}},options:d});continue}e(J,m[E],h,x,d)}return J};function e(j,d,x,m,J){const M=Object.keys(d).sort();for(const E of M){const h=d[E],F=Object.keys(h).sort();for(let o of F){const T=h[o];if(o==="@type")o=D;else if(s(o))continue;for(const L of T){const q={termType:E.startsWith("_:")?"BlankNode":"NamedNode",value:E};if(!k(E)){J.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:E}},options:J});continue}const y={termType:o.startsWith("_:")?"BlankNode":"NamedNode",value:o};if(!k(o)){J.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:o}},options:J});continue}if(y.termType==="BlankNode"&&!J.produceGeneralizedRdf){J.eventHandler&&n({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:m.getOldIds().find(U=>m.getId(U)===o)}},options:J});continue}const V=c(L,m,j,x,J.rdfDirection,J);V&&j.push({subject:q,predicate:y,object:V,graph:x})}}}}function i(j,d,x,m,J,M){const E={termType:"NamedNode",value:a},h={termType:"NamedNode",value:b},F={termType:"NamedNode",value:N},o=j.pop(),T=o?{termType:"BlankNode",value:d.getId()}:F;let L=T;for(const q of j){const y=c(q,d,x,m,J,M),V={termType:"BlankNode",value:d.getId()};x.push({subject:L,predicate:E,object:y,graph:m}),x.push({subject:L,predicate:h,object:V,graph:m}),L=V}if(o){const q=c(o,d,x,m,J,M);x.push({subject:L,predicate:E,object:q,graph:m}),x.push({subject:L,predicate:h,object:F,graph:m})}return T}function c(j,d,x,m,J,M){const E={};if(g.isValue(j)){E.termType="Literal",E.value=void 0,E.datatype={termType:"NamedNode"};let h=j["@value"];const F=j["@type"]||null;if(F==="@json")E.value=p(h),E.datatype.value=u;else if(r.isBoolean(h))E.value=h.toString(),E.datatype.value=F||w;else if(r.isDouble(h)||F===_)r.isDouble(h)||(h=parseFloat(h)),E.value=h.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),E.datatype.value=F||_;else if(r.isNumber(h))E.value=h.toFixed(0),E.datatype.value=F||O;else if("@direction"in j&&J==="i18n-datatype"){const o=(j["@language"]||"").toLowerCase(),T=j["@direction"],L=`https://www.w3.org/ns/i18n#${o}_${T}`;E.datatype.value=L,E.value=h}else{if("@direction"in j&&J==="compound-literal")throw new A("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:J});if("@direction"in j&&J)throw new A("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:J});"@language"in j?("@direction"in j&&!J&&M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:E.value}},options:M}),E.value=h,E.datatype.value=F||l,E.language=j["@language"]):("@direction"in j&&!J&&M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:E.value}},options:M}),E.value=h,E.datatype.value=F||H)}}else if(g.isList(j)){const h=i(j["@list"],d,x,m,J,M);E.termType=h.termType,E.value=h.value}else{const h=r.isObject(j)?j["@id"]:j;E.termType=h.startsWith("_:")?"BlankNode":"NamedNode",E.value=h}return E.termType==="NamedNode"&&!k(E.value)?(M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:E.value}},options:M}),null):E}return Xe}var Qe,Jt;function pn(){if(Jt)return Qe;Jt=1;const{isKeyword:v}=se(),s=re(),g=ee(),p=te(),A=ie(),r=ne(),{createNodeMap:t,mergeNodeMapGraphs:n}=de(),a={};Qe=a,a.frameMergedOrDefault=(e,i,c)=>{const j={options:c,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},d=new p.IdentifierIssuer("_:b");t(e,j.graphMap,"@default",d),c.merged&&(j.graphMap["@merged"]=n(j.graphMap),j.graph="@merged"),j.subjects=j.graphMap[j.graph];const x=[];a.frame(j,Object.keys(j.subjects).sort(),i,x),c.pruneBlankNodeIdentifiers&&(c.bnodesToClear=Object.keys(j.bnodeMap).filter(m=>j.bnodeMap[m].length===1));// remove @preserve from results
return c.link={},O(x,c)},a.frame=(e,i,c,j,d=null)=>{u(c),c=c[0];const x=e.options,m={embed:D(c,x,"embed"),explicit:D(c,x,"explicit"),requireAll:D(c,x,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const J=e.link[e.graph],M=l(e,i,c,m),E=Object.keys(M).sort();for(const h of E){const F=M[h];if(d===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},m.embed==="@link"&&h in J){H(j,d,J[h]);continue}const o={"@id":h};if(h.indexOf("_:")===0&&p.addValue(e.bnodeMap,h,o,{propertyIsArray:!0}),J[h]=o,(m.embed==="@first"||m.embed==="@last")&&e.is11)throw new r("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:c});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(h))){if(e.embedded&&(m.embed==="@never"||N(F,e.graph,e.subjectStack))){H(j,d,o);continue}if(e.embedded&&(m.embed=="@first"||m.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(h)){H(j,d,o);continue}if(m.embed==="@last"&&h in e.uniqueEmbeds[e.graph]&&_(e,h),e.uniqueEmbeds[e.graph][h]={parent:j,property:d},e.subjectStack.push({subject:F,graph:e.graph}),h in e.graphMap){let T=!1,L=null;"@graph"in c?(L=c["@graph"][0],T=!(h==="@merged"||h==="@default"),g.isObject(L)||(L={})):(T=e.graph!=="@merged",L={}),T&&a.frame({...e,graph:h,embedded:!1},Object.keys(e.graphMap[h]).sort(),[L],o,"@graph")}"@included"in c&&a.frame({...e,embedded:!1},i,c["@included"],o,"@included");for(const T of Object.keys(F).sort()){if(v(T)){if(o[T]=p.clone(F[T]),T==="@type")for(const L of F["@type"])L.indexOf("_:")===0&&p.addValue(e.bnodeMap,L,o,{propertyIsArray:!0});continue}if(!(m.explicit&&!(T in c)))for(const L of F[T]){const q=T in c?c[T]:b(m);if(s.isList(L)){const y=c[T]&&c[T][0]&&c[T][0]["@list"]?c[T][0]["@list"]:b(m),V={"@list":[]};H(o,T,V);const U=L["@list"];for(const G of U)s.isSubjectReference(G)?a.frame({...e,embedded:!0},[G["@id"]],y,V,"@list"):H(V,"@list",p.clone(G))}else s.isSubjectReference(L)?a.frame({...e,embedded:!0},[L["@id"]],q,o,T):f(q[0],L)&&H(o,T,p.clone(L))}}for(const T of Object.keys(c).sort()){if(T==="@type"){if(!g.isObject(c[T][0])||!("@default"in c[T][0]))continue}else if(v(T))continue;const L=c[T][0]||{};if(!D(L,x,"omitDefault")&&!(T in o)){let y="@null";"@default"in L&&(y=p.clone(L["@default"])),g.isArray(y)||(y=[y]),o[T]=[{"@preserve":y}]}}for(const T of Object.keys(c["@reverse"]||{}).sort()){const L=c["@reverse"][T];for(const q of Object.keys(e.subjects))p.getValues(e.subjects[q],T).some(V=>V["@id"]===h)&&(o["@reverse"]=o["@reverse"]||{},p.addValue(o["@reverse"],T,[],{propertyIsArray:!0}),a.frame({...e,embedded:!0},[q],L,o["@reverse"][T],d))}H(j,d,o),e.subjectStack.pop()}}},a.cleanupNull=(e,i)=>{if(g.isArray(e))return e.map(j=>a.cleanupNull(j,i)).filter(j=>j);if(e==="@null")return null;if(g.isObject(e)){if("@id"in e){const c=e["@id"];if(i.link.hasOwnProperty(c)){const j=i.link[c].indexOf(e);if(j!==-1)return i.link[c][j];i.link[c].push(e)}else i.link[c]=[e]}for(const c in e)e[c]=a.cleanupNull(e[c],i)}return e};function b(e){const i={};for(const c in e)e[c]!==void 0&&(i["@"+c]=[e[c]]);return[i]}function N(e,i,c){for(let j=c.length-1;j>=0;--j){const d=c[j];if(d.graph===i&&d.subject["@id"]===e["@id"])return!0}return!1}function D(e,i,c){const j="@"+c;let d=j in e?e[j][0]:i[c];if(c==="embed"){if(d===!0)d="@once";else if(d===!1)d="@never";else if(d!=="@always"&&d!=="@never"&&d!=="@link"&&d!=="@first"&&d!=="@last"&&d!=="@once")throw new r("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return d}function u(e){if(!g.isArray(e)||e.length!==1||!g.isObject(e[0]))throw new r("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const i of p.asArray(e[0]["@id"]))if(!(g.isObject(i)||A.isAbsolute(i))||g.isString(i)&&i.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const i of p.asArray(e[0]["@type"]))if(!(g.isObject(i)||A.isAbsolute(i)||i==="@json")||g.isString(i)&&i.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function l(e,i,c,j){const d={};for(const x of i){const m=e.graphMap[e.graph][x];w(e,m,c,j)&&(d[x]=m)}return d}function w(e,i,c,j){let d=!0,x=!1;for(const m in c){let J=!1;const M=p.getValues(i,m),E=p.getValues(c,m).length===0;if(m==="@id"){if(g.isEmptyObject(c["@id"][0]||{})?J=!0:c["@id"].length>=0&&(J=c["@id"].includes(M[0])),!j.requireAll)return J}else if(m==="@type"){if(d=!1,E){if(M.length>0)return!1;J=!0}else if(c["@type"].length===1&&g.isEmptyObject(c["@type"][0]))J=M.length>0;else for(const h of c["@type"])g.isObject(h)&&"@default"in h?J=!0:J=J||M.some(F=>F===h);if(!j.requireAll)return J}else{if(v(m))continue;{const h=p.getValues(c,m)[0];let F=!1;if(h&&(u([h]),F="@default"in h),d=!1,M.length===0&&F)continue;if(M.length>0&&E)return!1;if(h===void 0){if(M.length>0)return!1;J=!0}else if(s.isList(h)){const o=h["@list"][0];if(s.isList(M[0])){const T=M[0]["@list"];s.isValue(o)?J=T.some(L=>f(o,L)):(s.isSubject(o)||s.isSubjectReference(o))&&(J=T.some(L=>k(e,o,L,j)))}}else s.isValue(h)?J=M.some(o=>f(h,o)):s.isSubjectReference(h)?J=M.some(o=>k(e,h,o,j)):g.isObject(h)?J=M.length>0:J=!1}}if(!J&&j.requireAll)return!1;x=x||J}return d||x}function _(e,i){const c=e.uniqueEmbeds[e.graph],j=c[i],d=j.parent,x=j.property,m={"@id":i};if(g.isArray(d)){for(let M=0;M<d.length;++M)if(p.compareValues(d[M],m)){d[M]=m;break}}else{const M=g.isArray(d[x]);p.removeValue(d,x,m,{propertyIsArray:M}),p.addValue(d,x,m,{propertyIsArray:M})}const J=M=>{const E=Object.keys(c);for(const h of E)h in c&&g.isObject(c[h].parent)&&c[h].parent["@id"]===M&&(delete c[h],J(h))};J(i)}/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */function O(e,i){if(g.isArray(e))return e.map(c=>O(c,i));if(g.isObject(e)){// remove @preserve
if("@preserve"in e)return e["@preserve"][0];if(s.isValue(e))return e;if(s.isList(e))return e["@list"]=O(e["@list"],i),e;if("@id"in e){const c=e["@id"];if(i.link.hasOwnProperty(c)){const j=i.link[c].indexOf(e);if(j!==-1)return i.link[c][j];i.link[c].push(e)}else i.link[c]=[e]}for(const c in e){if(c==="@id"&&i.bnodesToClear.includes(e[c])){delete e["@id"];continue}e[c]=O(e[c],i)}}return e}function H(e,i,c){g.isObject(e)?p.addValue(e,i,c,{propertyIsArray:!0}):e.push(c)}function k(e,i,c,j){if(!("@id"in c))return!1;const d=e.subjects[c["@id"]];return d&&w(e,d,i,j)}function f(e,i){const c=i["@value"],j=i["@type"],d=i["@language"],x=e["@value"]?g.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],m=e["@type"]?g.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],J=e["@language"]?g.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return x.length===0&&m.length===0&&J.length===0?!0:!(!(x.includes(c)||g.isEmptyObject(x[0]))||!(!j&&m.length===0||m.includes(j)||j&&g.isEmptyObject(m[0]))||!(!d&&J.length===0||J.includes(d)||d&&g.isEmptyObject(J[0])))}return Qe}var Ke,Ft;function gn(){if(Ft)return Ke;Ft=1;const v=ne(),{isArray:s,isObject:g,isString:p,isUndefined:A}=ee(),{isList:r,isValue:t,isGraph:n,isSimpleGraph:a,isSubjectReference:b}=re(),{expandIri:N,getContextValue:D,isKeyword:u,process:l,processingMode:w}=se(),{removeBase:_,prependBase:O}=ie(),{REGEX_KEYWORD:H,addValue:k,asArray:f,compareShortestLeast:e}=te(),i={};Ke=i,i.compact=async({activeCtx:d,activeProperty:x=null,element:m,options:J={}})=>{if(s(m)){let E=[];for(let h=0;h<m.length;++h){const F=await i.compact({activeCtx:d,activeProperty:x,element:m[h],options:J});F!==null&&E.push(F)}return J.compactArrays&&E.length===1&&(D(d,x,"@container")||[]).length===0&&(E=E[0]),E}const M=D(d,x,"@context");if(A(M)||(d=await l({activeCtx:d,localCtx:M,propagate:!0,overrideProtected:!0,options:J})),g(m)){if(J.link&&"@id"in m&&J.link.hasOwnProperty(m["@id"])){const y=J.link[m["@id"]];for(let V=0;V<y.length;++V)if(y[V].expanded===m)return y[V].compacted}if(t(m)||b(m)){const y=i.compactValue({activeCtx:d,activeProperty:x,value:m,options:J});return J.link&&b(m)&&(J.link.hasOwnProperty(m["@id"])||(J.link[m["@id"]]=[]),J.link[m["@id"]].push({expanded:m,compacted:y})),y}if(r(m)&&(D(d,x,"@container")||[]).includes("@list"))return i.compact({activeCtx:d,activeProperty:x,element:m["@list"],options:J});const E=x==="@reverse",h={},F=d;!t(m)&&!b(m)&&(d=d.revertToPreviousContext());const o=D(F,x,"@context");A(o)||(d=await l({activeCtx:d,localCtx:o,propagate:!0,overrideProtected:!0,options:J})),J.link&&"@id"in m&&(J.link.hasOwnProperty(m["@id"])||(J.link[m["@id"]]=[]),J.link[m["@id"]].push({expanded:m,compacted:h}));let T=m["@type"]||[];T.length>1&&(T=Array.from(T).sort());const L=d;for(const y of T){const V=i.compactIri({activeCtx:L,iri:y,relativeTo:{vocab:!0}}),U=D(F,V,"@context");A(U)||(d=await l({activeCtx:d,localCtx:U,options:J,propagate:!1}))}const q=Object.keys(m).sort();for(const y of q){const V=m[y];if(y==="@id"){let U=f(V).map(X=>i.compactIri({activeCtx:d,iri:X,relativeTo:{vocab:!1},base:J.base}));U.length===1&&(U=U[0]);const G=i.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}});h[G]=U;continue}if(y==="@type"){let U=f(V).map(S=>i.compactIri({activeCtx:F,iri:S,relativeTo:{vocab:!0}}));U.length===1&&(U=U[0]);const G=i.compactIri({activeCtx:d,iri:"@type",relativeTo:{vocab:!0}}),I=(D(d,G,"@container")||[]).includes("@set")&&w(d,1.1)||s(U)&&V.length===0;k(h,G,U,{propertyIsArray:I});continue}if(y==="@reverse"){const U=await i.compact({activeCtx:d,activeProperty:"@reverse",element:V,options:J});for(const G in U)if(d.mappings.has(G)&&d.mappings.get(G).reverse){const X=U[G],I=(D(d,G,"@container")||[]).includes("@set")||!J.compactArrays;k(h,G,X,{propertyIsArray:I}),delete U[G]}if(Object.keys(U).length>0){const G=i.compactIri({activeCtx:d,iri:y,relativeTo:{vocab:!0}});k(h,G,U)}continue}if(y==="@preserve"){const U=await i.compact({activeCtx:d,activeProperty:x,element:V,options:J});s(U)&&U.length===0||k(h,y,U);continue}if(y==="@index"){if((D(d,x,"@container")||[]).includes("@index"))continue;const G=i.compactIri({activeCtx:d,iri:y,relativeTo:{vocab:!0}});k(h,G,V);continue}if(y!=="@graph"&&y!=="@list"&&y!=="@included"&&u(y)){const U=i.compactIri({activeCtx:d,iri:y,relativeTo:{vocab:!0}});k(h,U,V);continue}if(!s(V))throw new v("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(V.length===0){const U=i.compactIri({activeCtx:d,iri:y,value:V,relativeTo:{vocab:!0},reverse:E}),G=d.mappings.has(U)?d.mappings.get(U)["@nest"]:null;let X=h;G&&(j(d,G,J),g(h[G])||(h[G]={}),X=h[G]),k(X,U,V,{propertyIsArray:!0})}for(const U of V){const G=i.compactIri({activeCtx:d,iri:y,value:U,relativeTo:{vocab:!0},reverse:E}),X=d.mappings.has(G)?d.mappings.get(G)["@nest"]:null;let R=h;X&&(j(d,X,J),g(h[X])||(h[X]={}),R=h[X]);const I=D(d,G,"@container")||[],S=n(U),B=r(U);let $;B?$=U["@list"]:S&&($=U["@graph"]);let P=await i.compact({activeCtx:d,activeProperty:G,element:B||S?$:U,options:J});if(B)if(s(P)||(P=[P]),!I.includes("@list"))P={[i.compactIri({activeCtx:d,iri:"@list",relativeTo:{vocab:!0}})]:P},"@index"in U&&(P[i.compactIri({activeCtx:d,iri:"@index",relativeTo:{vocab:!0}})]=U["@index"]);else{k(R,G,P,{valueIsArray:!0,allowDuplicate:!0});continue}if(S)if(I.includes("@graph")&&(I.includes("@id")||I.includes("@index")&&a(U))){let Q;R.hasOwnProperty(G)?Q=R[G]:R[G]=Q={};const W=(I.includes("@id")?U["@id"]:U["@index"])||i.compactIri({activeCtx:d,iri:"@none",relativeTo:{vocab:!0}});k(Q,W,P,{propertyIsArray:!J.compactArrays||I.includes("@set")})}else I.includes("@graph")&&a(U)?(s(P)&&P.length>1&&(P={"@included":P}),k(R,G,P,{propertyIsArray:!J.compactArrays||I.includes("@set")})):(s(P)&&P.length===1&&J.compactArrays&&(P=P[0]),P={[i.compactIri({activeCtx:d,iri:"@graph",relativeTo:{vocab:!0}})]:P},"@id"in U&&(P[i.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}})]=U["@id"]),"@index"in U&&(P[i.compactIri({activeCtx:d,iri:"@index",relativeTo:{vocab:!0}})]=U["@index"]),k(R,G,P,{propertyIsArray:!J.compactArrays||I.includes("@set")}));else if(I.includes("@language")||I.includes("@index")||I.includes("@id")||I.includes("@type")){let Q;R.hasOwnProperty(G)?Q=R[G]:R[G]=Q={};let W;if(I.includes("@language"))t(P)&&(P=P["@value"]),W=U["@language"];else if(I.includes("@index")){const z=D(d,G,"@index")||"@index",K=i.compactIri({activeCtx:d,iri:z,relativeTo:{vocab:!0}});if(z==="@index")W=U["@index"],delete P[K];else{let C;if([W,...C]=f(P[z]||[]),!p(W))W=null;else switch(C.length){case 0:delete P[z];break;case 1:P[z]=C[0];break;default:P[z]=C;break}}}else if(I.includes("@id")){const z=i.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}});W=P[z],delete P[z]}else if(I.includes("@type")){const z=i.compactIri({activeCtx:d,iri:"@type",relativeTo:{vocab:!0}});let K;switch([W,...K]=f(P[z]||[]),K.length){case 0:delete P[z];break;case 1:P[z]=K[0];break;default:P[z]=K;break}Object.keys(P).length===1&&"@id"in U&&(P=await i.compact({activeCtx:d,activeProperty:G,element:{"@id":U["@id"]},options:J}))}W||(W=i.compactIri({activeCtx:d,iri:"@none",relativeTo:{vocab:!0}})),k(Q,W,P,{propertyIsArray:I.includes("@set")})}else{const Q=!J.compactArrays||I.includes("@set")||I.includes("@list")||s(P)&&P.length===0||y==="@list"||y==="@graph";k(R,G,P,{propertyIsArray:Q})}}}return h}return m},i.compactIri=({activeCtx:d,iri:x,value:m=null,relativeTo:J={vocab:!1},reverse:M=!1,base:E=null})=>{if(x===null)return x;d.isPropertyTermScoped&&d.previousContext&&(d=d.previousContext);const h=d.getInverse();if(u(x)&&x in h&&"@none"in h[x]&&"@type"in h[x]["@none"]&&"@none"in h[x]["@none"]["@type"])return h[x]["@none"]["@type"]["@none"];if(J.vocab&&x in h){const q=d["@language"]||"@none",y=[];g(m)&&"@index"in m&&!("@graph"in m)&&y.push("@index","@index@set"),g(m)&&"@preserve"in m&&(m=m["@preserve"][0]),n(m)?("@index"in m&&y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in m&&y.push("@graph@id","@graph@id@set"),y.push("@graph","@graph@set","@set"),"@index"in m||y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in m||y.push("@graph@id","@graph@id@set")):g(m)&&!t(m)&&y.push("@id","@id@set","@type","@set@type");let V="@language",U="@null";if(M)V="@type",U="@reverse",y.push("@set");else if(r(m)){"@index"in m||y.push("@list");const X=m["@list"];if(X.length===0)V="@any",U="@none";else{let R=X.length===0?q:null,I=null;for(let S=0;S<X.length;++S){const B=X[S];let $="@none",P="@none";if(t(B))if("@direction"in B){const Q=(B["@language"]||"").toLowerCase(),W=B["@direction"];$=`${Q}_${W}`}else"@language"in B?$=B["@language"].toLowerCase():"@type"in B?P=B["@type"]:$="@null";else P="@id";if(R===null?R=$:$!==R&&t(B)&&(R="@none"),I===null?I=P:P!==I&&(I="@none"),R==="@none"&&I==="@none")break}R=R||"@none",I=I||"@none",I!=="@none"?(V="@type",U=I):U=R}}else{if(t(m))if("@language"in m&&!("@index"in m)){y.push("@language","@language@set"),U=m["@language"];const X=m["@direction"];X&&(U=`${U}_${X}`)}else"@direction"in m&&!("@index"in m)?U=`_${m["@direction"]}`:"@type"in m&&(V="@type",U=m["@type"]);else V="@type",U="@id";y.push("@set")}y.push("@none"),g(m)&&!("@index"in m)&&y.push("@index","@index@set"),t(m)&&Object.keys(m).length===1&&y.push("@language","@language@set");const G=c(d,x,m,y,V,U);if(G!==null)return G}if(J.vocab&&"@vocab"in d){const q=d["@vocab"];if(x.indexOf(q)===0&&x!==q){const y=x.substr(q.length);if(!d.mappings.has(y))return y}}let F=null;const o=[];let T=d.fastCurieMap;const L=x.length-1;for(let q=0;q<L&&x[q]in T;++q)T=T[x[q]],""in T&&o.push(T[""][0]);for(let q=o.length-1;q>=0;--q){const y=o[q],V=y.terms;for(const U of V){const G=U+":"+x.substr(y.iri.length);d.mappings.get(U)._prefix&&(!d.mappings.has(G)||m===null&&d.mappings.get(G)["@id"]===x)&&(F===null||e(G,F)<0)&&(F=G)}}if(F!==null)return F;for(const[q,y]of d.mappings)if(y&&y._prefix&&x.startsWith(q+":"))throw new v(`Absolute IRI "${x}" confused with prefix "${q}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:d});if(!J.vocab)if("@base"in d)if(d["@base"]){const q=_(O(E,d["@base"]),x);return H.test(q)?`./${q}`:q}else return x;else return _(E,x);return x},i.compactValue=({activeCtx:d,activeProperty:x,value:m,options:J})=>{if(t(m)){const F=D(d,x,"@type"),o=D(d,x,"@language"),T=D(d,x,"@direction"),L=D(d,x,"@container")||[],q="@index"in m&&!L.includes("@index");if(!q&&F!=="@none"&&(m["@type"]===F||"@language"in m&&m["@language"]===o&&"@direction"in m&&m["@direction"]===T||"@language"in m&&m["@language"]===o||"@direction"in m&&m["@direction"]===T))return m["@value"];const y=Object.keys(m).length,V=y===1||y===2&&"@index"in m&&!q,U="@language"in d,G=p(m["@value"]),X=d.mappings.has(x)&&d.mappings.get(x)["@language"]===null;if(V&&F!=="@none"&&(!U||!G||X))return m["@value"];const R={};return q&&(R[i.compactIri({activeCtx:d,iri:"@index",relativeTo:{vocab:!0}})]=m["@index"]),"@type"in m?R[i.compactIri({activeCtx:d,iri:"@type",relativeTo:{vocab:!0}})]=i.compactIri({activeCtx:d,iri:m["@type"],relativeTo:{vocab:!0}}):"@language"in m&&(R[i.compactIri({activeCtx:d,iri:"@language",relativeTo:{vocab:!0}})]=m["@language"]),"@direction"in m&&(R[i.compactIri({activeCtx:d,iri:"@direction",relativeTo:{vocab:!0}})]=m["@direction"]),R[i.compactIri({activeCtx:d,iri:"@value",relativeTo:{vocab:!0}})]=m["@value"],R}const M=N(d,x,{vocab:!0},J),E=D(d,x,"@type"),h=i.compactIri({activeCtx:d,iri:m["@id"],relativeTo:{vocab:E==="@vocab"},base:J.base});return E==="@id"||E==="@vocab"||M==="@graph"?h:{[i.compactIri({activeCtx:d,iri:"@id",relativeTo:{vocab:!0}})]:h}};function c(d,x,m,J,M,E){E===null&&(E="@null");const h=[];if((E==="@id"||E==="@reverse")&&g(m)&&"@id"in m){E==="@reverse"&&h.push("@reverse");const o=i.compactIri({activeCtx:d,iri:m["@id"],relativeTo:{vocab:!0}});d.mappings.has(o)&&d.mappings.get(o)&&d.mappings.get(o)["@id"]===m["@id"]?h.push.apply(h,["@vocab","@id"]):h.push.apply(h,["@id","@vocab"])}else{h.push(E);const o=h.find(T=>T.includes("_"));o&&h.push(o.replace(/^[^_]+_/,"_"))}h.push("@none");const F=d.inverse[x];for(const o of J){if(!(o in F))continue;const T=F[o][M];for(const L of h)if(L in T)return T[L]}return null}function j(d,x,m){if(N(d,x,{vocab:!0},m)!=="@nest")throw new v("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}return Ke}var We,Ht;function yn(){return Ht||(Ht=1,We=v=>{class s{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(s,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(s.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:s}),s.compact=function(g,p){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):v.compact(g,p)},s.expand=function(g){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):v.expand(g)},s.flatten=function(g){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):v.flatten(g)},s}),We}/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2022 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var Ye,Ut;function vn(){if(Ut)return Ye;Ut=1;const v=et(),s=nn(),g=te(),p=on(),A=g.IdentifierIssuer,r=ne(),t=$t(),n=ln(),{expand:a}=cn(),{flatten:b}=un(),{fromRDF:N}=dn(),{toRDF:D}=hn(),{frameMergedOrDefault:u,cleanupNull:l}=pn(),{isArray:w,isObject:_,isString:O}=ee(),{isSubjectReference:H}=re(),{expandIri:k,getInitialContext:f,process:e,processingMode:i}=se(),{compact:c,compactIri:j}=gn(),{createNodeMap:d,createMergedNodeMap:x,mergeNodeMaps:m}=de(),{logEventHandler:J,logWarningEventHandler:M,safeEventHandler:E,setDefaultEventHandler:h,setupEventHandler:F,strictEventHandler:o,unhandledEventHandler:T}=ae(),L=function(y){const V={},G=new t({max:100});y.compact=async function(R,I,S){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(I===null)throw new r("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(R===null)return null;S=X(S,{base:O(R)?R:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new A("_:b"),contextResolver:new p({sharedCache:G})}),S.link&&(S.skipExpansion=!0),S.compactToRelative||delete S.base;let B;S.skipExpansion?B=R:B=await y.expand(R,S);const $=await y.processContext(f(S),I,S);let P=await c({activeCtx:$,element:B,options:S});S.compactArrays&&!S.graph&&w(P)?P.length===1?P=P[0]:P.length===0&&(P={}):S.graph&&_(P)&&(P=[P]),_(I)&&"@context"in I&&(I=I["@context"]),I=g.clone(I),w(I)||(I=[I]);const Q=I;I=[];for(let z=0;z<Q.length;++z)(!_(Q[z])||Object.keys(Q[z]).length>0)&&I.push(Q[z]);const W=I.length>0;if(I.length===1&&(I=I[0]),w(P)){const z=j({activeCtx:$,iri:"@graph",relativeTo:{vocab:!0}}),K=P;P={},W&&(P["@context"]=I),P[z]=K}else if(_(P)&&W){const z=P;P={"@context":I};for(const K in z)P[K]=z[K]}return P},y.expand=async function(R,I){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");I=X(I,{keepFreeFloatingNodes:!1,contextResolver:new p({sharedCache:G})});const S={},B=[];if("expandContext"in I){const W=g.clone(I.expandContext);_(W)&&"@context"in W?S.expandContext=W:S.expandContext={"@context":W},B.push(S.expandContext)}let $;if(!O(R))S.input=g.clone(R);else{const W=await y.get(R,I);$=W.documentUrl,S.input=W.document,W.contextUrl&&(S.remoteContext={"@context":W.contextUrl},B.push(S.remoteContext))}"base"in I||(I.base=$||"");let P=f(I);for(const W of B)P=await e({activeCtx:P,localCtx:W,options:I});let Q=await a({activeCtx:P,element:S.input,options:I});return _(Q)&&"@graph"in Q&&Object.keys(Q).length===1?Q=Q["@graph"]:Q===null&&(Q=[]),w(Q)||(Q=[Q]),Q},y.flatten=async function(R,I,S){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof I=="function"?I=null:I=I||null,S=X(S,{base:O(R)?R:"",contextResolver:new p({sharedCache:G})});const B=await y.expand(R,S),$=b(B);return I===null?$:(S.graph=!0,S.skipExpansion=!0,await y.compact($,I,S))},y.frame=async function(R,I,S){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(S=X(S,{base:O(R)?R:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new p({sharedCache:G})}),O(I)){const Y=await y.get(I,S);if(I=Y.document,Y.contextUrl){let Z=I["@context"];Z?w(Z)?Z.push(Y.contextUrl):Z=[Z,Y.contextUrl]:Z=Y.contextUrl,I["@context"]=Z}}const B=I?I["@context"]||{}:{},$=await y.processContext(f(S),B,S);S.hasOwnProperty("omitGraph")||(S.omitGraph=i($,1.1)),S.hasOwnProperty("pruneBlankNodeIdentifiers")||(S.pruneBlankNodeIdentifiers=i($,1.1));const P=await y.expand(R,S),Q={...S};Q.isFrame=!0,Q.keepFreeFloatingNodes=!0;const W=await y.expand(I,Q),z=Object.keys(I).map(Y=>k($,Y,{vocab:!0}));Q.merged=!z.includes("@graph"),Q.is11=i($,1.1);const K=u(P,W,Q);Q.graph=!S.omitGraph,Q.skipExpansion=!0,Q.link={},Q.framing=!0;let C=await y.compact(K,B,Q);return Q.link={},C=l(C,Q),C},y.link=async function(R,I,S){const B={};return I&&(B["@context"]=I),B["@embed"]="@link",y.frame(R,B,S)},y.normalize=y.canonize=async function(R,I){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(I=X(I,{base:O(R)?R:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new p({sharedCache:G})}),"inputFormat"in I){if(I.inputFormat!=="application/n-quads"&&I.inputFormat!=="application/nquads")throw new r("Unknown canonicalization input format.","jsonld.CanonizeError");const $=n.parse(R);return v.canonize($,I)}const S={...I};delete S.format,S.produceGeneralizedRdf=!1;const B=await y.toRDF(R,S);return v.canonize(B,I)},y.fromRDF=async function(R,I){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");I=X(I,{format:O(R)?"application/n-quads":void 0});const{format:S}=I;let{rdfParser:B}=I;if(S){if(B=B||V[S],!B)throw new r("Unknown input format.","jsonld.UnknownFormat",{format:S})}else B=()=>R;const $=await B(R);return N($,I)},y.toRDF=async function(R,I){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");I=X(I,{base:O(R)?R:"",skipExpansion:!1,contextResolver:new p({sharedCache:G})});let S;I.skipExpansion?S=R:S=await y.expand(R,I);const B=D(S,I);if(I.format){if(I.format==="application/n-quads"||I.format==="application/nquads")return n.serialize(B);throw new r("Unknown output format.","jsonld.UnknownFormat",{format:I.format})}return B},y.createNodeMap=async function(R,I){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");I=X(I,{base:O(R)?R:"",contextResolver:new p({sharedCache:G})});const S=await y.expand(R,I);return x(S,I)},y.merge=async function(R,I,S){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!w(R))throw new TypeError('Could not merge, "docs" must be an array.');typeof I=="function"?I=null:I=I||null,S=X(S,{contextResolver:new p({sharedCache:G})});const B=await Promise.all(R.map(Y=>{const Z={...S};return y.expand(Y,Z)}));let $=!0;"mergeNodes"in S&&($=S.mergeNodes);const P=S.issuer||new A("_:b"),Q={"@default":{}};for(let Y=0;Y<B.length;++Y){const Z=g.relabelBlankNodes(B[Y],{issuer:new A("_:b"+Y+"-")}),oe=$||Y===0?Q:{"@default":{}};if(d(Z,oe,"@default",P),oe!==Q)for(const le in oe){const fe=oe[le];if(!(le in Q)){Q[le]=fe;continue}const nt=Q[le];for(const he in fe)he in nt||(nt[he]=fe[he])}}const W=m(Q),z=[],K=Object.keys(W).sort();for(let Y=0;Y<K.length;++Y){const Z=W[K[Y]];H(Z)||z.push(Z)}return I===null?z:(S.graph=!0,S.skipExpansion=!0,await y.compact(z,I,S))},Object.defineProperty(y,"documentLoader",{get:()=>y._documentLoader,set:R=>y._documentLoader=R}),y.documentLoader=async R=>{throw new r("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:R})},y.get=async function(R,I){let S;typeof I.documentLoader=="function"?S=I.documentLoader:S=y.documentLoader;const B=await S(R);try{if(!B.document)throw new r("No remote document found at the given URL.","jsonld.NullRemoteDocument");O(B.document)&&(B.document=JSON.parse(B.document))}catch($){throw new r("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:$,remoteDoc:B})}return B},y.processContext=async function(R,I,S){return S=X(S,{base:"",contextResolver:new p({sharedCache:G})}),I===null?f(S):(I=g.clone(I),_(I)&&"@context"in I||(I={"@context":I}),e({activeCtx:R,localCtx:I,options:S}))},y.getContextValue=se().getContextValue,y.documentLoaders={},y.useDocumentLoader=function(R){if(!(R in y.documentLoaders))throw new r('Unknown document loader type: "'+R+'"',"jsonld.UnknownDocumentLoader",{type:R});y.documentLoader=y.documentLoaders[R].apply(y,Array.prototype.slice.call(arguments,1))},y.registerRDFParser=function(R,I){V[R]=I},y.unregisterRDFParser=function(R){delete V[R]},y.registerRDFParser("application/n-quads",n.parse),y.registerRDFParser("application/nquads",n.parse),y.url=ie(),y.logEventHandler=J,y.logWarningEventHandler=M,y.safeEventHandler=E,y.setDefaultEventHandler=h,y.strictEventHandler=o,y.unhandledEventHandler=T,y.util=g,Object.assign(y,g),y.promises=y,y.RequestQueue=zt(),y.JsonLdProcessor=yn()(y),s.setupGlobals(y),s.setupDocumentLoaders(y);function X(R,{documentLoader:I=y.documentLoader,...S}){if(R&&"compactionMap"in R)throw new r('"compactionMap" not supported.',"jsonld.OptionsError");if(R&&"expansionMap"in R)throw new r('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:I},S,R,{eventHandler:F({options:R})})}return y},q=function(){return L(function(){return q()})};return L(q),Ye=q,Ye}var Xt=vn();const mn=Qt(Xt),Ln=Wt({__proto__:null,default:mn},[Xt]);export{Ln as j};
